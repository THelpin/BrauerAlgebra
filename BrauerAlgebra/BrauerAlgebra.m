(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
xAct`BrauerAlgebra`$Version={"1.1.0",{2023,11,25}}


(* ::Input::Initialization:: *)
(* BrauerAlgebra : The Brauer algebra; Traces and permutations *)

(* Copyright (C) 2020 T. Helpin *)

(* This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License,or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

*)


(* ::Input::Initialization:: *)
(* :Title: BrauerAlgebra *)

(* :Author: Thomas Helpin *)

(* :Summary: Brauer Algebra; Traces and permutations. *)

(* :Brief Discussion:  *)
  
(* :Context: BrauerAlgebra` *)

(* :Package Version: 0.1.0 *)

(* :Copyright: T.Helpin (2020) *)

(* :History: TODO *)

(* :Keywords: TODO *)

(* :Source: BrauerAlgebra.nb *)

(* :Warning:  *)

(* :Mathematica Version: 8.0 and later *)

(* :Limitations: *)
	
(* :Acknowledgements: *)


(* ::Input::Initialization:: *)
Off[General::nostdvar]
Off[General::nostdopt]
BeginPackage["xAct`BrauerAlgebra`",{"xAct`SymmetricFunctions`"}]


(* ::Input::Initialization:: *)
Print["------------------------------------------------------------"];
Print["xAct`BrauerAlgebra  version ",$Version[[1]],", ",$Version[[2]]];
Print["Copyright (C) 2020-2022, Thomas Helpin, under the General Public License."];


(* ::Input::Initialization:: *)
Off[General::shdw]
BrauerAlgebra`Disclaimer[]:=Print["These are points 11 and 12 of the General Public License:\n\nBECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM `AS IS\.b4 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\nIN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES."]
On[General::shdw]


(* ::Input::Initialization:: *)
(*Print["These packages come with ABSOLUTELY NO WARRANTY; for details type Disclaimer[]. This is free software, and you are welcome to redistribute it under certain conditions. See the General Public License for details."];*)


BrauerDOIToString[text_,doi_]:="\!\(\*ButtonBox[StyleBox[\""<>text<>"\", \"SR\"],Active->True,BaseStyle->\"Link\",ButtonData->\"http://dx.doi.org/"<>doi<>"\"]\)";
BrauerDocumentationReplacements:= {"<v>" -> "\!\(\*StyleBox[\"" , "</v>" -> "\", \"TI\"]\)", "<f>"->"\!\(\*StyleBox[\"", "</f>" -> "\", \"Input\"]\)"} 
BrauerciteBrauer1937=BrauerDOIToString["[Brauer 1937]","10.2307/1968843"];
BrauercitePuchala17=BrauerDOIToString["[Puchala&Miszczak 2017]","10.48550/arXiv.1109.4244"];
BrauerciteJanusz66=BrauerDOIToString["[Janusz 1966]","10.2307/2035203"];
BrauerciteKing16=BrauerDOIToString["[King&Martin&Parker 2016]","10.48550/arXiv.1609.01183"];
BrauerciteShalile13=BrauerDOIToString["[Shalile 2013]","10.1007/s10468-011-9294-2"];
BrauerciteSamra79=BrauerDOIToString["[Samra&King 1979]","10.1088/0305-4470/12/12/010"];
BrauerciteRobinson61=BrauerDOIToString["[Robinson 1961]","10.1017/CBO9781107340732"];
BrauerciteNazarov96=BrauerDOIToString["[Nazarov 1996]","10.1006/jabr.1996.0195"];
BrauerciteCox09=BrauerDOIToString["[Cox&&De Visscher&&Martin 2007]","10.48550/arXiv.math/0601387"];
BrauerciteRui05=BrauerDOIToString["[Rui 2005]","10.1016/j.jcta.2004.11.009"];
BrauerciteWillenbring01=BrauerDOIToString["[Willenbring 2001]","10.1006/jabr.2001.8828"];
BrauerciteMacDonald95=BrauerDOIToString["[MacDonald 1995]","10.1112/blms/13.2.180"];
BrauerciteFulton96=BrauerDOIToString["[Fulton 1996]","10.1017/CBO9780511626241"];
BrauerciteMurphy81=BrauerDOIToString["[Murphy 1981]","10.1016/0021-8693(81)90205-2"];
BrauerciteJucys74=BrauerDOIToString["[Jucys 1974]","10.1016/0034-4877(74)90019-6"];
BrauerciteBrown56=BrauerDOIToString["[Brown 1956]","10.2307/1969613"];
BrauerciteRam95=BrauerDOIToString["[Ram 1995]","10.2140/pjm.1995.169.173"];
BrauerciteShalile11=BrauerDOIToString["[Shalile 2011]","10.1016/j.jpaa.2011.03.014"];
BrauerciteCollins06=BrauerDOIToString["[Collins&\:015aniady 2006]","10.1007/s00220-006-1554-3"];
BrauerciteCollins09=BrauerDOIToString["[Collins&Matsumoto 2009]","10.1063/1.3251304"];
BrauerciteDoty19=BrauerDOIToString["[Doty&Lauve&Seelinger 2019]","10.4171/LEM/64-1/2-2"];
BrauerciteBulgakova22=BrauerDOIToString["[Bulgakova&Goncharov&Helpin 2022]","10.48550/arXiv.2212.14496"];


(* ::Input::Initialization:: *)
(*** VERSIONS ***)
$Version::usage="$Version is a global variable giving the version of the package BrauerAlgebra in use.";


(***********************************************************************************************)
(***********************************************************************************************)
(************************** Basic function for the Brauer Algebra ******************************)
(***********************************************************************************************)
(***********************************************************************************************)

(*** Heads for the elements of Subscript[B, n]  ****)
DownInteger::usage="DownInteger is the head for the integers labelling the down vertices of a diagram in the Brauer algebra \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)). DownInteger[k] returns the DownInteger \!\(\*UnderscriptBox[\(k\), \(_\)]\)
associated to the integer k.";
BrauerList::usage=StringReplace["BrauerList is the head for the list associated to a diagram in the Brauer algebra \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)) "<>BrauerciteBrauer1937<>". 
The list is an ordered disjoint union of pair partitions of the set of integers {1,...,n,DownInteger[1],...,DownInteger[n]}.",BrauerDocumentationReplacements];
BrauerCycles::usage="BrauerCycles[{\!\(\*SubscriptBox[\(cyc\), \(1\)]\),\!\(\*SubscriptBox[\(cyc\), \(2\)]\),...}] represents an element of the Brauer algebra in a cycle notation which generalizes the Build-in Cycles notation of mathematica
for permutations.";
BrauerGraph::usage="BrauerGraph is the head for the Graph associated to a diagram in \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)).";
(********************)
(*** Generalities ***)
(********************)
OrderBrauer::usage="OrderBrauer[n,{f}] returns the number of diagrams in \!\(\*SubscriptBox[\(B\), \(n\)]\) with exactly f arcs. 
OrderBrauer[n,f] returns the number of diagrams in \!\(\*SubscriptBox[\(B\), \(n\)]\) with at least f arcs (dimension of the ideal \!\(\*SubscriptBox[\(J\), \(f\)]\)\[Subset]\!\(\*SubscriptBox[\(B\), \(n\)]\)).
OrderBrauer[n] returns the number of diagrams in \!\(\*SubscriptBox[\(B\), \(n\)]\) (dimension of \!\(\*SubscriptBox[\(B\), \(n\)]\)).";
Narcs::usage="Narcs[d] returns the number of up (resp. down) arcs of the BrauerList d \[Element] \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)). It can also be applied to Bracelets objects.";
Nlines::usage="Nlines[d] returns the number of passing lines of the BrauerList d \[Element] \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)). It can also be applied to Bracelets objects.";
Ncrossing::usage="Ncrossing[d] returns the number of crossing edges of the BrauerList d \[Element] \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)).";
SignatureBrauer::usage="SignatureBrauer[d] returns the signature of the BrauerList d \[Element] \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)). SignatureBrauer[d]=(-1\!\(\*SuperscriptBox[\()\), \(Ncrossing[d]\)]\) ";
SymmetricGroupQ::usage="SymmetricGrouQ[d] returns True if the BrauerList d \[Element] \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)) is a permutation. It can also be applied to Bracelets objects.";
PermToBrauer::usage="PermToBrauer[cycle,n]/PermToBrauer[list] transform a permutation (Cycles/PermutationList) into a BrauerList.";
BrauerToPerm::usage="BrauerToPerm[d] translates a permutation in the BrauerList form d into the Cycles/PermutationList form of Mathematica.";
BrauerDiagram::usage="BrauerDiagram[d] returns a BrauerGraph object corresponding to the BrauerList d in \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)).";
ToBrauerList::usage="ToBrauerList[x] returns the BrauerList associated to x where x can have the head BrauerGraph or Bracelets. 
ToBrauerList[x,n] returns the BrauerList associated to x where x can have the head BrauerCycles, GeneratorTrace, GeneratorPerm, JucysMurphyS or JucysMurphyB, Bracelets, ClassSum.";
BrauerElements::usage="BrauerElements[n] returns a list of all basis vectors in the Brauer algebra \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)),\
 namely the elements of the set of the disjoint union of pair partitions on 2n symbols.
BrauerElements[n,f] returns the list of elements in \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)) with f arcs.";
BrauerElementsCycles::usage="BrauerElementsCycles[n] returns a list of all basis vectors in the Brauer algebra \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\))
in the cycles notation.";
ToBrauerCycles::usage="ToBrauerCycles[exp] translates all occurences of diagrams (head BrauerList) in exp to the BrauerCycles notation.";
IdentityBrauer::usage="IdentityBrauer[n] returns the identiy in \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)) in the form of a BrauerList.
IdentityBrauer[] returns GeneratorPerm[0].";
CycleType::usage=StringReplace["CycleType[d] returns the cycle type of the element d in \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)) in the form of an integer partition with zeros allowed.
The cycle type is constant on conjugacy classes. CycleType[btab] returns the cycle type of any diagram in the conjugacy class paramatrized by the Bracelets btab.  "<>BrauerciteRam95<>BrauerciteShalile11<>".",BrauerDocumentationReplacements];
(** Generators of the Brauer algebra ***)
GeneratorPerm::usage="GeneratorPerm is the head for the permutation generators in \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)). 
GeneratorPerm[i] returns the symbolic \!\(\*SuperscriptBox[\(i\), \(th\)]\) permutation generators in \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)). By convention we set GeneratorPerm[0] as the identity in \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)).";
GeneratorTrace::usage="GeneratorTrace is the head for the trace generators in \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)). 
GeneratorTrace[i] returns the symbolic \!\(\*SuperscriptBox[\(i\), \(th\)]\) trace generators in \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)).";
BrauerGenerators::usage="BrauerGenerators[n] returns a generating set for the Brauer algebra \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)).";
ToGenerators::usage="ToGenerators[jm] returns an expression of the Jucys-Mpurhy element jm in terms of the generator of the Brauer algebra.";
(** Multiplication in Brauer **)
BrauerParameter::usage="The scalar \!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\) resulting from the contraction of two arcs in the product of two diagrams in \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)). 
In the context of Schur-Weyl duality the Brauer algebra is recognize as the centralizer algebra of the action of O(N) (or Sp(N)) on \!\(\*SuperscriptBox[\(V\), \(\(\[TensorProduct]\)\(n\)\)]\). 
In this case \!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\) is to be identify with \[Epsilon]N where N is the dimension of the vector space V and \[Epsilon]=1 for O(N) and \[Epsilon]=-1 for Sp(N).";
SetBrauerParamaterTo::usage="SetBrauerParamaterTo[N] set the function BrauerParameter[] to N globally.";
BrauerProduct::usage="(******************** Product between BrauerList objects *********************)
BrauerProduct[d1,d2] returns the product of diagrams d1 with d2 where d1 and d2 have the head BrauerList.
The option ProductConvention allows one to choose its farovite convention for the product. It can takes the value Below or Above. 
BrauerProduct[d1,d2,ProductConvention->Below] computes the product by placing d1 below d2. 
BrauerProduct[d1,d2,ProductConvention->Above] computes the product by placing d1 above d2. The default value is Below. 
BrauerProduct[d1, d2, d3, ...] returns the product of d1, d2, d3 ... . 
BrauerProduct works for elements of the algebra. 
(*********************** Product between genetors and symbols  *********************************)
BrauerProduct[d1, d2, d3, ...] also outputs the product of d1, d2, d3 ..., where d1, d2, d3 ... have either the head Symbol, GeneratorPerm, GeneratorTrace, JucysMurphyS or JucysMurphyB.
The product of generators can be reduced using ToReducedWord.";
ProductConvention::usage="ProductConvention is an option for BrauerProduct. The default value is Below. The other setting is Above."
Output::usage="Output is an option for BrauerGenerators, JucysMurphy, YoungSymmetrizer and SemiNormalYoungUnit. 
For BrauerGenerators and JucysMurphy it can take the value Symbol or BrauerList (the default value is Symbol). For YoungSymmetrizer and SemiNormalYoungUnit 
it can take the value Cycles or BrauerList (the default value is Cycles).";
SymmetricGroupOnly::usage="SymmetricGroupOnly is a booleen option for BrauerGenerators and JucysMurphy.";
(** Jucys Murphy elements in the Brauer Algebra : in developpement **)
JucysMurphyS::usage="JucysMurphyS is the head for the Jucys-Murphy elements in the symmetric group algebra. 
JucysMurphyS[i] returns the symbolic \!\(\*SuperscriptBox[\(i\), \(th\)]\) Jucys-Murphy element in the algebra.";
JucysMurphyB::usage="JucysMurphyB is the head for the Jucys-Murphy elements in the Brauer algebra. 
JucysMurphyB[i] returns the symbolic \!\(\*SuperscriptBox[\(i\), \(th\)]\) Jucys-Murphy element in the algebra.";
JucysMurphy::usage=StringReplace["JucysMurphy[n] returns the list of Jucys-Murphy elements in \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\))."<>BrauerciteJucys74<>BrauerciteMurphy81<>" see also "<>BrauerciteNazarov96<>"",BrauerDocumentationReplacements];
ToReducedWord::usage="ToReducedWord[exp] reduces exp via the defining relation of \!\(\*SubscriptBox[\(B\), \(n\)]\)(\[Delta]).
In general the result is not fully reduced. (It would be nice to have a normal form for the Brauer algebra.)";
(****************************************************************************************)
(****************************************************************************************)
(************************** Tools from the symmetric Group ******************************)
(****************************************************************************************)
(****************************************************************************************)

(******** Young operators and seminormal Young Operators ****)
PermNotation::usage="PermNotation is an option for BrauerToPerm. It can take the value Cycle or PermutationList.";
(*StandardTableaux::usage="StandardTableaux[n] return a list of all standard Young tableaux associated with the partitions of n.";
TransposePartition::usage="TransposePartition[\[Mu]] return the transpose partition of \[Mu].";*)
TransposeTableau::usage="TransposeTableau[tab] returns the transpose young tableau of tab.";
(*DimOfIrrepSn::usage="DimOfIrrepSn[\[Mu]] returns the dimension of the irreducible representation of the symmetric group associated to the partition \[Mu].";*)

(*NumberOfTableaux::usage="NumberOfTableaux[n] returns the numbers of standard tableau for the partitions of the integer n.";*)
(*BratteliPathSn::usage="BratteliPathSn[tab] returns the path in the Bratteli diagram of Subscript[S, n] associated to the standard tableau tab.";
BratteliDiagramSn::usage="BrattelidiagramSn[n] returns the Bratteli diagram of Subscript[S, n] (Young's lattice) that is formed by all integer partitions from 1 to n.";*)

YoungSymmetrizer::usage="YoungSymmetrizer[stdtab] returns the Young projector associated to the standard tableau stdtab.";
SemiNormalYoungUnit::usage="SemiNormalYoungUnit[stdtab] returns the semi-normal Young projector associated to the standard tableau stdtab.";
CentralYoungProjector::usage=StringReplace["CentralYoungProjector[\[Mu]] returns the central Young projector for the partition \[Mu] in terms of the conjugacy class sum in the Bracelets format: 
see for example "<>BrauerciteJanusz66<>".",BrauerDocumentationReplacements];
CentralYoung::usage="CentralYoung[\[Mu]] returns an object with the head CentralYoung corresponding to the central idempotent 
associated with the direct sum of equivalent simple module of the symmetric group labeled by the partition \[Mu].";
SimplifyCentralYoung::usage="SimplifyCentralYoung[exp] simplifies the product of CentralYoung in exp using the fact that the central Young operators are idempotents
and pairwise orthogonal.";
ExpandCentralYoung::usage="ExpandCentralYoung[exp] expresses all occurences in exp of objects with the head CentralYoung in terms of Bracelets.";
BraceletsToCentralYoung::usage="BraceletsToCentralYoung[exp] expresses all occurences of conjugacy class sums (with the head Bracelets) 
of the symmetric group in terms of CentralYoung.";
ManifestSym::usage="ManifestSym is an option for YoungSymmetrizer that specifies with which convention one construct the Young Symmetrizer from a given
standard tableau. 
The default is Symmetric, with which first the columns are antisymmetrized and lastly the rows are symmetrized, resulting in an expression which is manifestly 
row symmetric. The other setting is Antisymmetric, with which first the rows of the diagram are symmetrized 
and lastly the columns antisymmetrized, resulting in an expression which is manifestly column antisymmetric.";

(** Characters of the symmetric group : from the Package IntU by Zbigniew Puchala **)
(*CharacterSymmetricGroup::usage=StringReplace["CharacterSymmetricGroup[\[Lambda],\[Mu]] gives the character of the symmetric group \[Chi]^(\[Lambda]) evaluated at \[Mu].
CharacterSymmetricGroup[\[Lambda]] returns the character of the symmetric group \[Chi]^(\[Lambda]) evaluated at the identity. 
This function is borrowed from the package IntU developed by Z. Puchala and J. Miszczak "<>BrauercitePuchala17<>".",BrauerDocumentationReplacements];*)


(****************************************************************************************)
(****************************************************************************************)
(***************************** Conjugacy classes in Brauer ******************************)
(****************************************************************************************)
(****************************************************************************************)

(**** Equivalence class of brauer diagrams averaging with the symmetric group ***)
Bracelets::usage=StringReplace["Bracelets is the head for the list which parametrizes the \!\(\*SubscriptBox[\(S\), \(n\)]\) conjugacy class in \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)). 
They correspond to concatenation of particular words (bracelets) in a ternary alphabet (1,2,3) where each word have the same number of 1 and 2. 
Two words are equilavent if they are related by cyclic permutations and inversions. A canonical representative is accesible with the function ToCanonicalBracelets[bracelets].
The letters 1,2, and 3 represent North arcs, South arcs, and Propagating lines respectively.
See for example "<>BrauerciteKing16<>BrauerciteShalile13<>".",BrauerDocumentationReplacements];
BrauerBracelets::usage="BrauerBracelets[n,\!\(\*SubscriptBox[\(f\), \(1\)]\),\!\(\*SubscriptBox[\(f\), \(2\)]\)] returns the list of (1,2,3) (Brauer)-Bracelets on n letters with \!\(\*SubscriptBox[\(f\), \(1\)]\) to \!\(\*SubscriptBox[\(f\), \(2\)]\) letters 1 (resp. 2). They parametrize
the conjugacy classes in \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)) with \!\(\*SubscriptBox[\(f\), \(1\)]\) to \!\(\*SubscriptBox[\(f\), \(2\)]\) arcs and have the head Bracelets.
BrauerBracelets[n,f] returns the list of Bracelets objects with n letters and exactly f letters 1 (resp. 2).
BrauerBracelets[n] returns the list of all Bracelets objects with n letters.";
ToBracelets::usage="ToBracelets[d] returns the Bracelets object which parametrizes the \!\(\*SubscriptBox[\(S\), \(n\)]\) conjugacy class of d."
TableauForm::usage="Transform a list into a young tableau format.";
BraceletForm::usage="BraceletForm[bracelets] returns a graphical reprensation of bracelets.";
ToCanonicalBracelets::usage="ToCanonicalBracelets[bracelets] returns a canonical representative for bracelets.";
Flip::usage="Flip[d] flips the diagram d with respect to the horizontal line. Flip[bracelets] swaps the letters 1 and 2 in bracelets and returns a canonical representative.
Flip[exp] flips all occurences of elements of the Brauer algebra or bracelets in exp.";
InvolutionQ::usage="InvolutionQ[d] returns true if the element of \!\(\*SubscriptBox[\(B\), \(n\)]\)(\[Delta]) d is invariant under the flip operation.";
NumberOfBracelets::usage=StringReplace["NumberOfBracelets[n] returns the number of conjugacy class \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\))"<>BrauerciteWillenbring01<>".",BrauerDocumentationReplacements];
ConjugacyClass::usage="ConjugacyClass[d] returns the list of the elements which are \!\(\*SubscriptBox[\(S\), \(n\)]\)-conjugate to d in \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)). 
ConjugacyClass[bracelets] returns the conjugacy class associated with the Bracelets bracelets.";
ConjugacyClassSum::usage="ConjugacyClassSum[d] returns the sum of diagrams in the \!\(\*SubscriptBox[\(S\), \(n\)]\)-conjugacy class of d in \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)). It can also be applied to Bracelets objects.";
ToRepresentativeDiagram::usage="ToRepresentativeDiagram[bracelets] yield the representative diagram corresponding to the Bracelets bracelets.";
AClass::usage=StringReplace["AClass[n,f] returns the Bracelets associated to the conjugacy class of flip invariant f-arcs diagrams with vertical lines.
The construction of the traceless projector relies heavily on AClass[n,1] and the space of traceless tensor of order n is annihilated by AClass[n,1]. See Lemma 3.1 "<>BrauerciteBulgakova22<>".",BrauerDocumentationReplacements];
TClass::usage="TClass[n,t] returns the Bracelets associated to the conjugacy class of \!\(\*SubscriptBox[\(S\), \(n\)]\) whose elements are flip invariant (involutions) which are the product of t disjoint transpositions.";
IdClass::usage="IdClass[n] returns the Identity bracelets.";
StabilityIndex::usage="StabilitIndex[bracelet]";

(****************************************************************************************)
(****************************************************************************************)
(**************** Algebra of Conjugacy classes and Traceless projectors *****************)
(****************************************************************************************)
(****************************************************************************************)

StructureConstant::usage"StructureConstant[bracelet] return the structure constant matrix of the action of bracelet on the \!\(\*SubscriptBox[\(S\), \(n\)]\) centralizer of \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)). 
This function admits three boolean options SymmetricGroup, FactorSpace, IdealSpace.";
IdealSpace::usage="IdealSpace is booleen option for StructureConstant. Let J(f) in \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)) be the space of diagram with at least f arcs.\
 There a chain of ideals in the Brauer algebra : J(n) \[Subset] J(n-1) \[Subset] ... \[Subset] J(1) \[Subset] J(0)=\!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)).";
FactorSpace::usage="FactorSpace is booleen option for ConjugacyClassRelations. One can define a product in the factor space consisting of \
diagram with exaclty m arcs : J[m]=J(m)/J(m+1). For example the symmetric group algebra is \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\))/J(1).";
ConjugacyClassProduct::usage="ConjugacyClassProduct[bracelet1,bracelet2], performs the product of the conjugacy class sum associated with the bracelet1
 with the one associated with the bracelet2. The entries bracelets1 and bracelets2 have either the Head ClassSum or Bracelets. 
This function is optimized for the conjugacy class sum \!\(\*SubscriptBox[\(A\), \(n\)]\)(1) and \!\(\*SubscriptBox[\(T\), \(n\)]\)(1)(AClass[n,1] and TClass[n,1]) which are the most simple transposition class sums.";
ConjugacyClassRelations::usage="ConjugacyClassRelations[bracelets,{f1,f2}, dim] returns all product between the bracelets (Head Bracelets) and the others Brauer bracelets (with the same number letter as in bracelets)
 corresponding to the conjugacy class sums with f1 to f2 arcs using dim as the parameter for the product in \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)). The default value for dim is \!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\).
ConjugacyClassRelations[bracelets,{f}, dim] is equivalent to ConjugacyClassRelations[bracelets,{f,f}, dim].
ConjugacyClassRelations[bracelets,dim] returns all product relations between the class bracelets and others classes in the algebra of conjugacy classes.";

(**** New Head ClassSum and related functions ****)
ClassSum::usage="ClassSum is the Head for the conjugacy class sums of \!\(\*SubscriptBox[\(S\), \(n\)]\) and of \!\(\*SubscriptBox[\(B\), \(n\)]\). Use ClassSum[\[Mu]] to return the conjugacy class sum associated with \[Mu].
Here \[Mu] is either an integer partition (in which case ClassSum[\[Mu]] belongs to the symmetric group algebra), or a ternary bracelets with the head Bracelets
(in which case ClassSum[\[Mu]] belongs to the Brauer algebra).";
ToClassSum::usage="ToClassSum[\[Mu]] returns ClassSum[\[Mu]] where \[Mu] is either an integer partition or a ternary bracelets with Head Bracelets.";

(****************************************************************************************)
(****************************************************************************************)
(********************* Representation theory of the Brauer algebra **********************)
(****************************************************************************************)
(****************************************************************************************)
BratteliDiagramBn::usage="BrattelidiagramBn[n] returns the Bratteli diagram of the Brauer algebra \!\(\*SubscriptBox[\(B\), \(n\)]\).";
BratteliPathBn::usage="BratteliPathBn[n,\[Mu]] returns the set of paths in the Bratteli diagram of the Brauer algebra \!\(\*SubscriptBox[\(B\), \(n\)]\) which ends with the partition \[Mu].
Note that this function should not be compared with BratteliPathSn.";
DimOfIrrepBn::usage="DimOfIrrepBn[n,\[Mu]] returns the dimension of the irreducible representation of the Brauer algebra associated to the integer n and to the partition \[Mu].";
BranchingRule::usage="Experimental : BranchingRule[\[Mu],SymmetricGroup[n1],SymmetricGroup[n2]] ... BranchingRule[\[Mu],GeneralLinearGroup[N],OrthogonalGroup[N]]... 
BranchingRule[\[Mu],GeneralLinearGroup[N],SymplecticGroup[N]]. 
BranchingRule[\[Mu],BrauerAlgebra[n1],BrauerAlgebra[n2]] ... BranchingRule[\[Mu],BrauerAlgebra[n],SymmetricGroup[n]].
";
IrrepsOfBrauer::usage="IrrepsOfBrauer[n] returns a list of the partition indexing the irreducible representations of the Brauer algebra.";
BrauerAlgebra::usage="BrauerAlgebra[n,\[Delta]] is a parameter for BranchingRule. Also BrauerElements[BrauerAlgebra[n,\[Delta]]] returns the diagramatic basis of \!\(\*SubscriptBox[\(B\), \(n\)]\) where \[Delta] is optional.";
SchurWeylDual::usage=StringReplace["ShurWeylDual is an option for TracelessProjector and EigenvaluesA. It can take the values OrthogonalGroup, SymplecticGroup or None.
The default value for TracelessProjector is OrthogonalGroup, the default value for EigenvaluesA is None.
See for example : "<>BrauerciteBrown56<>".",BrauerDocumentationReplacements];
OrthogonalGroup::usage="OrthogonalGroup is an option value for EigenvaluesA and TracelessProjector.";
SymplecticGroup::usage="SymplecticGroup is an option value for EigenvaluesA and TracelessProjector.";

(*DimOfIrrepGL::usage=StringReplace["DimOfIrrepGL[\[Mu],N] returns the dimension of the irrep of the general linear group GL[N] associated to the partition \[Mu] where N is either an integer  or a symbol.
DimOfIrrepGL[\[Mu]] returns the dimension of the irrep of the general linear linear group GL[Subscript[\[Delta], d]] associated to the partition \[Mu] (Implicititly Subscript[\[Delta], d] is to be understood as an integer here).
See for example p 60 of "<>BrauerciteRobinson61<>".",BrauerDocumentationReplacements];
DimOfIrrepO::usage=StringReplace["DimOfIrrepO[\[Mu],N] returns the dimension of the irrep of the orthogonal group O[N] associated to the partition \[Mu] where N is either an integer  or a symbol.
DimOfIrrepO[\[Mu]] returns the dimension of the orthogonal group O[Subscript[\[Delta], d]] irrep associated to the partition \[Mu] (Implicititly Subscript[\[Delta], d] is to be understood as an integer here).
We use the formula presented in "<>BrauerciteSamra79<>".",BrauerDocumentationReplacements];
DimOfIrrepSp::usage=StringReplace["DimOfIrrepSp[\[Mu],N] returns the dimension of the irrep of the symplectic group Sp[N] associated to the partition \[Mu] where N is either an integer  or a symbol.
DimOfIrrepSp[\[Mu]] returns the dimension of the irrep of the symplectic group Sp[Subscript[\[Delta], d]] associated to the partition \[Mu] (Implicititly Subscript[\[Delta], d] is to be understood as an integer here).
We use the formula presented in "<>BrauerciteSamra79<>".",BrauerDocumentationReplacements];*)





(***************************************************************************************************************)
(***************************************************************************************************************)
(****************************** Combinatorics (Now in the package SymmetricFunctions) **************************)
(***************************************************************************************************************)
(***************************************************************************************************************)

(*LittlewoodRichardsonRule::usage=StringReplace["LittlewoodRichardsonRule[\[Nu],\[Lambda]] returns a list of the partitions \[Mu] (with multiplicities) such that |\[Mu]|=|\[Nu]|+|\[Lambda]| appearing in the outer product of \[Nu] with \[Lambda]."<>BrauerciteFulton96<>"",BrauerDocumentationReplacements];
LRTableaux::usage=StringReplace["LRTableaux[\[Mu],\[Lambda]] returns a list of semi-standard skew shape \[Mu]/\[Lambda] with row word a lattice permutation. 
LRTableaux[\[Mu],\[Lambda],\[Nu]] returns a list of semi-standard skew shape \[Mu]/\[Lambda] with weight \[Nu] and row word a lattice permutation."<>BrauerciteMacDonald95<>"
This function is borrowed from the package SchurFs developed by K. Ohmori.",BrauerDocumentationReplacements];
LittlewoodRichardsonCoefficient::usage="LittlewoodRichardsonCoefficient[\[Mu],\[Nu],\[Lambda]] returns the Littlewood-Richardson coefficient Subscript[C^\[Mu], \[Nu]\[Lambda]] : \[Nu]\[TensorProduct]\[Lambda]=Subscript[\[CapitalSigma]C^\[Mu], \[Nu]\[Lambda]] \[Mu], where \[Nu],\[Lambda] and \[Mu] 
are irreducible representations of GL. This correspond to Length[LRTableaux[\[Mu],\[Lambda],\[Nu]]].
LittlewoodRichardsonCoefficient[\[Mu],\[Nu]] enumerates the partitions \[Lambda] with its non vanishing LittlewoodRichardsonCoefficient Subscript[C^\[Mu], \[Nu]\[Lambda]].
LittlewoodRichardsonCoefficient[\[Mu]] enumerates the pairs of partitions (\[Lambda],\[Nu]) with its non vanishing LittlewoodRichardsonCoefficient Subscript[C^\[Mu], \[Nu]\[Lambda]].";
NewellLittlewoodCoefficient::usage="NewellLittlewoodCoefficient[\[Mu],\[Nu],\[Lambda]] returns the Newell-Littlewood coefficient Subscript[N^\[Mu], \[Nu]\[Lambda]] : \[Nu]\[TensorProduct]\[Lambda]=Subscript[\[CapitalSigma]N^\[Mu], \[Nu]\[Lambda]] \[Mu], where \[Nu],\[Lambda] and \[Mu] 
are irreducible representations of SO, O, or Sp.";
NewellLittlewoodRule::usage="To do";
InverseLittlewoodRichardsonRule::usage="InverseLittlewoodRichardsonRule[\[Mu],\[Nu]] returns the list of the partitions \[Lambda] such that \[Mu] \[Element] LittlewoodRichardsonRule[\[Nu],\[Lambda]]. This also correspond to the weigths of
the skew-shape tableaux in LRTableaux[\[Mu],\[Nu]].";*)

(***************************************************************************************************************)
(***************************************************************************************************************)
(********************************* Central idempotent and traceless projection *********************************)
(***************************************************************************************************************)
(***************************************************************************************************************)
EigenvaluesA::usage=StringReplace["(********** The eigenvalues of class \!\(\*SubscriptBox[\(A\), \(n\)]\)(1) are essential in the construction of the traceless projectors/central idempotents. **********) 
(**********                    They are computed using the Littewood-Richardson rule. See for example : "<>BrauerciteNazarov96<>BrauerciteCox09<>"     **********) 
(* Case 1 : the product parameter \[Delta] in the Brauer Algebra is symbolic *)
EigenvaluesA[\[Mu],\[Lambda],\[Delta]] where \[Mu]\[RightTee]n and \[Lambda]\[RightTee]n-2f returns the eigenvalue of \!\(\*SubscriptBox[\(A\), \(n\)]\)(1) on a simple \!\(\*SubscriptBox[\(S\), \(n\)]\)-module \!\(\*SuperscriptBox[\(L\), \(\[Mu]\)]\) (appearing in the decomposition of a simple \!\(\*SubscriptBox[\(B\), \(n\)]\)(\[Delta])-module \!\(\*SuperscriptBox[\(M\), \(\[Lambda]\)]\) upon restriction to \!\(\*SubscriptBox[\(S\), \(n\)]\)).
EigenvaluesA[\[Mu],\[Delta]] returns the eigenvalues of \!\(\*SubscriptBox[\(A\), \(n\)]\)(1) on a simple \!\(\*SubscriptBox[\(S\), \(n\)]\)-module \!\(\*SuperscriptBox[\(L\), \(\[Mu]\)]\) (appearing in the decomposition of the simple \!\(\*SubscriptBox[\(B\), \(n\)]\)(\[Delta]) module upon restriction to \!\(\*SubscriptBox[\(S\), \(n\)]\)). 
EigenvaluesA[n,\[Delta]] returns the eigenvalues of \!\(\*SubscriptBox[\(A\), \(n\)]\)(1) on all simple \!\(\*SubscriptBox[\(S\), \(n\)]\)-module \!\(\*SuperscriptBox[\(L\), \(\[Mu]\)]\) with \[Mu]\[RightTee]n (appearing in the decomposition of the simple \!\(\*SubscriptBox[\(B\), \(n\)]\)(\[Delta]) module upon restriction to \!\(\*SubscriptBox[\(S\), \(n\)]\)).
The input \[Delta] is optional, the default value is BrauerParameter[].
(* Case 2 : the product parameter \[Delta] in the Brauer Algebra is an integer *)
EigenvaluesA[\[Mu],\[Lambda],\[Epsilon]N,option], EigenvaluesA[\[Mu],\[Epsilon]N,option], EigenvaluesA[n,\[Epsilon]N,option] returns the eigenvalues of class \!\(\*SubscriptBox[\(A\), \(n\)]\)(1) with further constraints depending on the integer \[Epsilon]N and on the 
choice for the value of the option SchurWeylDual. One can choose either SchurWeylDual->None, SchurWeylDual->OrthogonalGroup or SchurWeylDual->SymplecticGroup.",BrauerDocumentationReplacements];

SplittingIdempotent::usage=StringReplace["SplittingIdempotent[n,f] returns the splitting idempotent of the short sequence 0->J(f)->\!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\))->\!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\))/J(f)."<>BrauerciteKing16<>" 
When f=1 it corresponds to the traceless projector TracelessProjector[n].",BrauerDocumentationReplacements];
IdentityJf::usage="IdentityJf[n,f] returns the identity in terms of Bracelets in the ideal J(f)\[Subset]\!\(\*SubscriptBox[\(B\), \(n\)]\)(\[Delta]) corresponding to the space of diagram with at least f arcs.";
CentralIdempotent::usage="(* Case 1 : the product parameter \[Delta] in the Brauer Algebra is symbolic *)
CentralIdempotent[n,\[Lambda],\[Delta]] returns the central primitive idempotent which projects onto the direct sum of equivalent simple modules \!\(\*OverscriptBox[SubscriptBox[\(M\), \(n\)], \(\[Lambda]\)]\) of \!\(\*SubscriptBox[\(B\), \(n\)]\)(\[Delta]) where \[Lambda] is a partition of n-2f (f=0,1,...,\[LeftFloor]n/2\[RightFloor]).
All CentralIdempotent[n,\[Lambda],\[Delta]] are pairwise orthogonal and they form a complete set of central primitive orthogonal idempotents. 
CentralIdempotent[n,f,\[Delta]] returns the sum of CentralIdempotent[n,\[Lambda],\[Delta]] over the partitions \[Lambda] of n-2f. 
CentralIdempotent[n,f,\[Delta]] correspond to the (f+1)-traceless projectors with the convention of the package. The input \[Delta] is optional, the default value is BrauerParameter[].
(* Case 2 : the product parameter \[Delta] in the Brauer Algebra is an integer *).";

(*CentralIdempotentBranching::usage="CentralIdempotentBranching[n,{\[Mu],\[Lambda]},\[Delta]]";*)
CanonicalPrimitiveIdempotent::usage=StringReplace["CanonicalPrimitiveIdempotent[n,path,\[Delta]] returns the canonical primitive idempotent in \!\(\*SubscriptBox[\(B\), \(n\)]\)(\[Delta]) associated  with
the path path in the Bratteli diagram "<>BrauerciteDoty19<>".",BrauerDocumentationReplacements];

TraceProjector::usage="TraceProjector[n,{\[Delta]}] gives the central idempotent in \!\(\*SubscriptBox[\(B\), \(n\)]\)(\[Delta]) which projects onto the last simple module of \!\(\*SubscriptBox[\(B\), \(n\)]\)(\[Delta]) parametrized by either the empty partition when 
n is even (scalar invariant) or the partition {1} when n is odd.";
TracelessProjector::usage=StringReplace["(*********** Schur-Weyl duality not considered : \!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\) is a parameter ************)
TracelessProjector[n] returns the traceless projector in \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)) in terms of conjugacy class sums. 
TracelessProjector[n,f] returns the f-traceless projector in \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)) in terms of conjugacy class sums. 
(*********** Schur-Weyl duality may be considered : \!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\) is an integer ************)
TracelessProjector[n,f,{\[Epsilon]N}] returns the f-traceless projector in \!\(\*SubscriptBox[\(B\), \(n\)]\)(\[Epsilon]N) where \[Epsilon]=\[PlusMinus]1 and N is positive integer."<>BrauerciteBulgakova22<>" (* This function is still experimental for f>1 *)

(********************************** Options *********************************)
An important option of this function for application to tensor calculus is SchurWeylDual. 
It can take the value OrthogonalGroup, SymplecticGroup or None. This option is effective only when \[Epsilon]N appears in the input.",BrauerDocumentationReplacements];
Dressed::usage="Dressed is an option for SnTracelessProjector. It can take the value None or CentralYoungProjector. The default value is None.";
SnTracelessProjector::usage="(*********** Schur-Weyl duality not considered : \!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\) is a parameter ************)
SnTracelessProjector[n,\[Mu]] returns the reduced-traceless projector in \!\(\*SubscriptBox[\(B\), \(n\)]\)(\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)) for simple \!\(\*SubscriptBox[\(S\), \(n\)]\)-module parametrized by \[Mu].
(*********** Schur-Weyl duality may be considered : \!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\) is an integer ************)
SnTracelessProjector[n,\[Mu],\[Epsilon]N] returns the traceless projector for simple \!\(\*SubscriptBox[\(S\), \(n\)]\)-module parametrized by partition \[Mu] where \!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)=\[Epsilon]N with \[Epsilon]=\[PlusMinus]1 and N an integer. 
(********************************** Options *********************************)
There is two options for this functions. The first is SchurWeylDual. It can take the value OrthogonalGroup, SymplecticGroup or None. 
This option is effective only when \[Epsilon]N appears in the input and its default value is OrthogonalGroup.
The second option is Dressed. It can take the value None or CentralYoungProjector. The default value is None.";


(****************************************************************************************)
(****************************************************************************************)
(***************************** Weingarten Calculus **************************************)
(****************************************************************************************)
(****************************************************************************************)

(****************************************************************************************)
(***************************** HyperOctahedral Group ************************************)
(****************************************************************************************)
HyperOctahedralQ::usage="HyperOctahedralQ[perm] returns True if perm belong to the HyperOctahedral group, False otherwise.";
HyperOctahedralGenerators::usage="HyperOctahedralGenerators[n] returns the generating set for the hyperoctahedral group.";
HyperOctahedralGroup::usage="HyperOctahedralGroup[n] define the hyper-octahedral group as a Mathematica PermutationGroup.";
CosetType::usage="CosetType[perm] returns the coset type of perm.";


(** Weingarten calculus functions for the unitary group **)
WeingartenU::usage=StringReplace["WeingartenU[\[Mu],N] returns the value of the Weingarten function for the Unitary group U(N) with \[Mu] a partition corresponding to the cycle type of a permutation. 
N is either a symbol or an integer."<>BrauerciteCollins06<>" 
WeingartenU[\[Mu]]==WeingartenU[\[Mu],\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)].",BrauerDocumentationReplacements];

(** Weingarten calculus functions for the orthogonal group **)
ZonalSpherical::usage="To do.";
ZonalPolynomialId::usage=StringReplace["ZonalPolynomialId[\[Mu],N] returns the zonal polynomial \!\(\*SubscriptBox[\(Z\), \(\[Mu]\)]\)(\!\(\*SuperscriptBox[\(1\), \(N\)]\)).",BrauerDocumentationReplacements];
WeingartenO::usage=StringReplace["WeingartenO[d1,d2,N] returns the value of the Weingarten function for O(N) evaluated at the element d1 and d2 of \!\(\*SubscriptBox[\(B\), \(n\)]\)(N)."<>BrauerciteCollins09<>"  
The elements d1, d2 have the head BrauerList and N is either an integer or a symbol. WeingartenO[d1,d2]==WeingartenO[d1,d2,\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)].
WeingartenO[btab,N] returns the value of the Weingarten function for O(N) evaluated at btab. The argument btab has the head Bracelets and is a concatenation of bracelets on an even number of letters with only 1 and 2.  
WeingartenO[btab]==WeingartenO[btab,\!\(\*SubscriptBox[\(\[Delta]\), \(b\)]\)].",BrauerDocumentationReplacements];


(****************************************************************************************)
(****************************************************************************************)
(************************* Characters in the Brauer algebra *****************************)
(****************************************************************************************)
(****************************************************************************************)
(* To do *)

(*****************************************************************************************************)
(*****************************************************************************************************)
(*******************************  ? Walled Brauer part : nothing is done yet *************************)
(*****************************************************************************************************)
(*****************************************************************************************************)

(* To do *)


(******************** At the end we delete the citation from the Names **************************)
Remove["BrauerciteCollins06","BrauerciteJanusz66","BrauerciteKing16","BrauercitePuchala17","BrauerciteShalile13","BrauerDocumentationReplacements",
"BrauerDOIToString","doi","text","BrauerciteCox09","BrauerciteNazarov96","BrauerciteRobinson61","BrauerciteRui05","BrauerciteSamra79","BrauerciteBrauer1937","BrauerciteWillenbring01","BrauerciteJucys74","BrauerciteMurphy81","BrauerciteFulton96",
"BrauerciteMacDonald95","BrauerciteBrown56","BrauerciteCollins09","BrauerciteRam95","BrauerciteShalile11","BrauerciteDoty19","BrauerciteBulgakova22"]


(* ::Input::Initialization:: *)
Begin["`Private`"]


(* ::Input::Initialization:: *)
(****** This function is borrowed to xCore Package : Jos\[EAcute] M. Mart\[IAcute]n-Garc\[IAcute]a
jose@xact.es
(c) 2007-2020,under GPL ****)
CheckOptions[]:={};
CheckOptions[opts__]:=If[OptionQ[{opts}]&&MemberQ[{1,2},ArrayDepth[{opts}]],
Flatten[{opts},1],
Throw[Message[CheckOptions::invalid,opts,"option or list of options"]]];
Protect[CheckOptions];


(* ::Input::Initialization:: *)
DownInteger/:MakeBoxes[DownInteger[i_Integer],StandardForm]:=UnderscriptBox[MakeBoxes[i,StandardForm],"_"];
MakeExpression[UnderscriptBox[i_,"_"],StandardForm]:=MakeExpression[RowBox[{"DownInteger","[",i,"]"}],StandardForm];


(* ::Input::Initialization:: *)
(********** Private function to handle down integers ******)
UpInteger[DownInteger[n_]]:=n;
UpInteger[n_Integer]:=n;
ChangeInteger[DownInteger[n_]]:=n;
ChangeInteger[n_]:=DownInteger[n];
DownInteger[DownInteger[n_]]:=Hold[DownInteger[n]]


(* ::Input::Initialization:: *)
(*********** Order for DownInteger ****)
DownInteger/:Greater[DownInteger[a_],DownInteger[b_]|b_Integer]:=Greater[a,b]
DownInteger/:Greater[DownInteger[a_]|a_Integer,DownInteger[b_]]:=Greater[a,b]
DownInteger/:GreaterEqual[DownInteger[a_],DownInteger[b_]|b_Integer]:=GreaterEqual[a,b]
DownInteger/:GreaterEqual[DownInteger[a_]|a_Integer,DownInteger[b_]]:=GreaterEqual[a,b]
DownInteger/:Less[DownInteger[a_],DownInteger[b_]|b_Integer]:=Less[a,b]
DownInteger/:Less[DownInteger[a_]|a_Integer,DownInteger[b_]]:=Less[a,b]
DownInteger/:LessEqual[DownInteger[a_],DownInteger[b_]|b_Integer]:=LessEqual[a,b]
DownInteger/:LessEqual[DownInteger[a_]|a_Integer,DownInteger[b_]]:=LessEqual[a,b]


(* ::Input::Initialization:: *)
SetAttributes[ChangeInteger,Listable]
SetAttributes[UpInteger,Listable]
SetAttributes[DownInteger,Listable]


(* ::Input::Initialization:: *)
BrauerList/:MakeBoxes[BrauerList[blist_List],StandardForm]:=SubscriptBox[MakeBoxes[blist,StandardForm],"B"];
MakeExpression[SubscriptBox[b_,"B"],StandardForm]:=MakeExpression[RowBox[{"BrauerList","[",b,"]"}],StandardForm];


(* ::Input::Initialization:: *)
OrderBrauer[n_,{f_}]:=(n-2f)!(Product[Binomial[n-2i,2]/(i+1),{i,0,f-1}])^2;
OrderBrauer[n_,f_]:=Plus@@Map[OrderBrauer[n,{#}]&,Range[f,IntegerPart[n/2]]];
OrderBrauer[n_]:=(2n-1)!!;


(* ::Input::Initialization:: *)
GenLines[k_?EvenQ]:=Flatten@With[{r=Range@k},
Fold[With[{l1=#,l2=#2},Flatten[Map[With[{la=#,c=Complement[r,#]},Map[Join[la,c[[#]]]&,l2]]&,l1],1]]&,Map[Subsets[Range@#,{2},#-1][[Range[IntegerPart[#/2],#-1]]]&,Range[k,2,-2]]]];
GenArcs[f_]:=With[{r=Range@(2*f)},Flatten@Fold[With[{l1=#,l2=#2},Flatten[Map[With[{la=#,c=Complement[r,#]},Join[la,c[[#]]]&/@l2]&,l1],1]]&,Subsets[Range@#,{2},#-1]&/@Range[#,2,-2]&@(2*f)]];


(* ::Input::Initialization:: *)
SubsetsArcsUp[n_,f_]:=Subsets[Range[n],{2f}];
SubsetsArcsDown[n_,f_]:=Subsets[DownInteger[Range[n]],{2f}];
SubsetsArcs[n_,f_]:=Flatten[Outer[Join,SubsetsArcsUp[n,f],SubsetsArcsDown[n,f],1],1]
SubsetsArcsLines[n_,f_]:=With[{support=Join[Range[n],DownInteger[Range[n]]]},Map[{#,Complement[support,#]}&,SubsetsArcs[n,f]]]


(* ::Input::Initialization:: *)
FormatList0[lst_,idx_]:=With[{l=Length@lst},ArrayReshape[lst[[idx]],{(l-1)!!,l/2,2}]];
FormatListArcs[lst_,genarcs_,f_]:=Flatten[Outer[Join,FormatList0[lst[[;;2*f]],genarcs],FormatList0[lst[[2*f+1;;4*f]],genarcs],1],1];
FormatListSym[lst_,idx_]:=With[{l=Length@lst},ArrayReshape[lst[[idx]],{(l/2)!,l/2,2}]];
FormatArcsLinesBrauer[lst_,n_,f_,genarcs_,genlines_]:=With[{listarcs=lst[[1]],listlines=lst[[2]]},Flatten[Outer[BrauerList[Sort[Join[#1,#2]]]&,FormatListArcs[listarcs,genarcs,f],FormatListSym[listlines,genlines],1],1]]


(* ::Input::Initialization:: *)
BrauerElements[n_,0]:=BrauerList/@FormatListSym[Join[Range[n],DownInteger/@Range[n]],GenLines[2*n]];
BrauerElements[n_,f_]:=If[n/2==f,With[{genarcs=GenArcs[f]},Flatten[Map[With[{lst=#},Flatten[Outer[BrauerList[Join[#1,#2]]&,FormatList0[lst[[;;2*f]],genarcs],FormatList0[lst[[2*f+1;;4*f]],genarcs],1],1]]&,SubsetsArcs[n,f]],1]],With[{genarcs=GenArcs[f],genlines=GenLines[2*(n-2f)]},Flatten[Map[FormatArcsLinesBrauer[#,n,f,genarcs,genlines]&,SubsetsArcsLines[n,f]],1]]];
BrauerElements[n_]:=Flatten[Map[BrauerElements[n,#]&,Range[0,IntegerPart[n/2]]],1];


(* ::Input::Initialization:: *)
(************ Ordering the list which represent a element in the Brauer algebra **********)
SortBrauerList[BrauerList[list_]]:=BrauerList[Sort[Map[Sort,list,1]]]


(* ::Input::Initialization:: *)
ExtendToBrauerCycles0[{list1_},{n1_}]:=Split[Map[MapAt[DownInteger,list1,Split@#]&,Subsets[Rest@Range[Length[list1]],{n1}]]];
ExtendToBrauerCycles0[{list1_}]:=Flatten[Map[ExtendToBrauerCycles0[{list1},{#}]&,Range[0,Length[list1]-1]],1]
ExtendToBrauerCycles0[{lists___},{ns___}]:=Flatten[Outer[Join,Sequence@@MapThread[ExtendToBrauerCycles0[{#1},{#2}]&,{{lists},{ns}}],1],1]
ExtendToBrauerCycles0[{list1_,list2__}]:=With[{nlists=Flatten[Outer[List,Sequence@@Map[Range[0,Length[#]-1]&,{list1,list2}],1],Length[{list2}]]},
Flatten[Map[ExtendToBrauerCycles0[{list1,list2},#]&,nlists],Length[{list2}]]
]


(* ::Input::Initialization:: *)
ExtendToBrauerCycles[System`Cycles[{}]]:={BrauerCycles[{}]}
ExtendToBrauerCycles[System`Cycles[{lists__}]]:=BrauerCycles/@ExtendToBrauerCycles0[{lists}]
BrauerElementsCycles[n_]:=Map[Sequence@@ExtendToBrauerCycles[#]&,GroupElements[SymmetricGroup[n]]]


(* ::Input::Initialization:: *)
(************* ToBrauerCycles *********************)
ToDisjointCyclesForBrauerCycles[x:BrauerList[list_],n_]:=DeleteCases[Map[Select[#,MemberQ[list,#]&]&,CollectIntersectingSublist[ToLoopBrauerList[x,n]]],_?(Length@#==1&)];
SelectNextCycleNumber0[list_]:={Rest[list],{list[[1,1]]},ChangeInteger[list[[1,2]]]}
SelectNextCycleNumber[{list_,Elementcycles_,k_}]:=With[{l=Select[list,MemberQ[#,k]&]},{Complement[list,l],Append[Elementcycles,k],ChangeInteger[Sequence@@DeleteCases[Flatten[l],k]]}]
ToBrauerCycles0[list_]:=Nest[SelectNextCycleNumber,SelectNextCycleNumber0[list],Length[list]-1][[2]];
ToBrauerCycles1[x:BrauerList[list_]]:=BrauerCycles[ToBrauerCycles0/@ToDisjointCyclesForBrauerCycles[x,Length[list]]];
ToBrauerCycles[exp_]:=exp/.x:BrauerList[list_]:>ToBrauerCycles1[x]


(* ::Input::Initialization:: *)
(************* ToBrauerList *********************)
ComplementaryCycle[list_]:=ChangeInteger[RotateLeft[list]]
CycleAsBrauerList[list_]:=Sort/@Thread[{list,ComplementaryCycle[list]}]
CyclesAsBrauerList[x:{list__}]:=Join@@Map[CycleAsBrauerList,x]
ToBrauerList0[BrauerCycles[{}],n_]:=IdentityBrauer[n];
ToBrauerList0[BrauerCycles[list__],n_]:=With[{comp=mycomplementSmall[Range[n],UpInteger[Flatten[list]]]},BrauerList[Sort[Join[Thread[{comp,DownInteger[comp]}],CyclesAsBrauerList[list]]]]]


(* ::Input::Initialization:: *)
BrauerGraph/:MakeBoxes[BrauerGraph[bgraph_Graph],StandardForm]:=SubscriptBox[MakeBoxes[bgraph,StandardForm],SubscriptBox["B","g"]];
MakeExpression[SubscriptBox[b_,SubscriptBox["B","g"]],StandardForm]:=MakeExpression[RowBox[{"BrauerGraph","[",b,"]"}],StandardForm];


(* ::Input::Initialization:: *)
(************** Ordering a BrauerList with respect to arcs and lines {arcsUp,arcsDown,lines} **************) 
ArcUpQ[List[a_,b_]]:=Head[b]===Integer;
ArcDownQ[List[a_,b_]]:=Head[a]===DownInteger;
LineQ[List[a_,b_]]:=Head[a]=!=Head[b];
ListArcsUp[BrauerList[list_]]:=Select[list,ArcUpQ[#]&];
ListArcsDown[BrauerList[list_]]:=Select[list,ArcDownQ[#]&];
ListLine[BrauerList[list_]]:=Select[list,LineQ[#]&];
BrauerListArcsLinesOrder[x:BrauerList[list_]]:={ListArcsUp[x],ListArcsDown[x],ListLine[x]};
(************** EdgeShapeFunction for arcs *************)
ESF[arcsup_,arcsdown_]:=
Join[Map[#->GraphElementData[{"CurvedArc","Curvature"->-1.1/(#[[2]]-#[[1]])-0.1}]&,Rule@@@arcsup],Map[#->GraphElementData[{"CurvedArc","Curvature"->1.1/(UpInteger[#[[2]]]-UpInteger[#[[1]]])+0.1}]&,Rule@@@arcsdown]]
(************** VertexCoordinates *************)
vertexcoordinates[n_,range_]:=With[{step2=(n+1)},Join[Map[#->{#-1,1}&,range[[;;n]]],Map[#->{UpInteger[#]-1,-1}&,range[[n+1;;2n]]]]];


(* ::Input::Initialization:: *)
Options[BrauerDiagram0]:={VertexSize->Tiny,ImageSize->40,EdgeStyle->Black,VertexStyle->Black,VertexLabels->None}
BrauerDiagram0[n_,x:{arcsUp_,arcsDown_,Lines_},options:OptionsPattern[]]:=With[{range=Join[Range[n],DownInteger[Range[n]]],edges=Map[UndirectedEdge[#[[1]],#[[2]]]&,Flatten[x,1]]},
Block[{brauerdiagram,imagesize,vertexsize,edgestyle,vertexlabels,vertexstyle},
{imagesize,vertexsize,edgestyle,vertexlabels,vertexstyle}=OptionValue[{BrauerDiagram0},{options},{ImageSize,VertexSize,EdgeStyle,VertexLabels,VertexStyle}];
If[vertexlabels===None,
brauerdiagram=BrauerGraph[Graph[range,edges,{VertexCoordinates->vertexcoordinates[n,range],EdgeShapeFunction ->ESF[arcsUp,arcsDown],EdgeStyle->edgestyle,VertexStyle->edgestyle,VertexSize->vertexsize, ImageSize ->imagesize}]]];
If[vertexlabels===Integers,
With[{vb=Map[If[#<=n,#->Placed[Style[ToString[#],FontFamily->"Latin Modern Roman",FontSize->16],Above],#->Placed[Style[ToString[#-n],FontFamily->"Latin Modern Roman",FontSize->16],Below]]&,range]},
brauerdiagram=BrauerGraph[Graph[range,edges,{VertexCoordinates->vertexcoordinates[n,range],EdgeShapeFunction ->ESF[arcsUp,arcsDown],EdgeStyle->edgestyle,VertexStyle->edgestyle,VertexSize->vertexsize, ImageSize ->imagesize,VertexLabels->vb}]]
]];
If[vertexlabels===Indexed,
With[{vb=Map[If[#<=n,#->Placed[Style[ToString[Subscript["i",ToString[#]],StandardForm],FontFamily->"Latin Modern Roman",FontSize->14],Above]]&,range]},
brauerdiagram=BrauerGraph[Graph[range,edges,{VertexCoordinates->vertexcoordinates[n,range],EdgeShapeFunction ->ESF[arcsUp,arcsDown],EdgeStyle->edgestyle,VertexStyle->edgestyle,VertexSize->vertexsize, ImageSize ->imagesize,VertexLabels->vb}]]
]];
Return[brauerdiagram,Block];
]
];
BrauerDiagram0[x:BrauerList[list_],options:OptionsPattern[]]:=BrauerDiagram0[Length[list],BrauerListArcsLinesOrder[x],options];
Options[BrauerDiagram]:={VertexSize->Tiny,ImageSize->40,EdgeStyle->Black,VertexStyle->Black,VertexLabels->None}
BrauerDiagram[exp_,options:OptionsPattern[]]:=exp/.x_BrauerList:>BrauerDiagram0[x,options]


(* ::Input::Initialization:: *)
ToBrauerList0[bgraph_BrauerGraph]:=BrauerList[Sort[List@@@EdgeList@@bgraph]];


(* ::Input::Initialization:: *)
(**** There is as much up arcs as down arcs in a Brauer diagram. The function Narcs count the number of up arcs. ***)
Narcs[BrauerList[list_]]:=Count[list,a_/;Head[a[[1]]]===DownInteger]
Nlines[x:BrauerList[list_]]:=Length[list]-2*Narcs[x];

(**** Bracelets is the head for the parametrization of conjugacy classes in Subscript[B, n](Subscript[\[Delta], b]) (See Section 6) : any time a function on a diagram makes sense for a conjugacy class we will automatically define it on conjugacy classes also. *****)

Narcs[exp_Bracelets]:=Count[Flatten[Sequence@@exp],1];
Nlines[exp_Bracelets]:=Count[Flatten[Sequence@@exp],1];


(* ::Input::Initialization:: *)
SymmetricGroupQ[blist_BrauerList]:=Narcs[blist]===0;
SymmetricGroupQ[btab_Bracelets]:=!MemberQ[Flatten@@btab,1];


(* ::Input::Initialization:: *)
permutationSignature1[perm_]:=Apply[Times,(-1)^(Length/@First[perm]-1)]
SignatureBrauer[d_System`Cycles]:=permutationSignature1[d ]
SignatureBrauer[d_?SymmetricGroupQ]:=permutationSignature1[BrauerToPerm[d,PermNotation->Cycles]]


(* ::Input::Initialization:: *)
ArcQ[{a_,b_}]:=Head[a]===Head[b]
LineQ[{a_,b_}]:=Head[a]=!=Head[b]


(* ::Input::Initialization:: *)
CrossingQ[list1_,list2_]:=With[{aQ1=ArcQ[list1],aQ2=ArcQ[list2],a=list1[[1]],b=list1[[2]],c=list2[[1]],d=list2[[2]]},
If[!aQ1&&!aQ2,(b>d),If[aQ1&&aQ2,(b>c&&d>b&&Head[a]===Head[c]),If[(aQ1&&!aQ2),b>c,If[!aQ1&&aQ2,c<b&&d>b&&Head[a]=!=Head[c]]]]]
]


(* ::Input::Initialization:: *)
Ncrossing[x:BrauerList[list_]]:=Count[Map[CrossingQ[Sequence@@#]&,Subsets[list,{2}]],True]
SignatureBrauer[d_?(!SymmetricGroupQ[#]&)]:=(-1)^Ncrossing[d]


(* ::Input::Initialization:: *)
(***** Private function ***)
BrauerToPermutationList[x:BrauerList[list_]]:=(list[[All,2]]/.DownInteger->Sequence); 


(* ::Input::Initialization:: *)
(***** Public function ***)
Options[BrauerToPerm0]:={PermNotation->Cycles}
BrauerToPerm0[d_?SymmetricGroupQ,options:OptionsPattern[]]:=Module[{permNotation},
{permNotation}=OptionValue[{BrauerToPerm},{options},{PermNotation}];
If[permNotation===Cycles,
PermutationCycles[BrauerToPermutationList[d]],
BrauerToPermutationList[d]]
];
Options[BrauerToPerm]:={PermNotation->Cycles}
BrauerToPerm[exp_,options:OptionsPattern[]]:=exp/.x_BrauerList:>BrauerToPerm0[x,options]


(* ::Input::Initialization:: *)
PermToBrauer0[perm_?PermutationListQ]:=BrauerList[Flatten[{Range[Length[perm]],DownInteger/@perm},{2}]];
PermToBrauer0[perm_System`Cycles,n_Integer]:=PermToBrauer0[PermutationList[perm,n]];
PermToBrauer[exp_,n_]:=exp/.x_System`Cycles:>PermToBrauer0[x,n]
PermToBrauer[exp_]:=exp/.x_?PermutationListQ:>PermToBrauer0[x]


(* ::Input::Initialization:: *)
Flip0[BrauerList[list_]]:=BrauerList[Sort[Map[Sort[ChangeInteger[#]]&,list]]];
Flip0[perm_System`Cycles]:=InversePermutation[perm];
Flip0[bracelets_Bracelets]:=ToCanonicalBracelets[bracelets/.{1->2,2->1}]
Flip[exp_]:=exp/.x:BrauerList[list_]:>Flip0[x]/.y:Bracelets[list_]:>Flip0[y]/. y_System`Cycles:>Flip0[y]
InvolutionQ[d_BrauerList]:=Flip0[d]===d;
InvolutionQ[Bracelets[list_]]:=Max[Length/@list]==2;


(* ::Input::Initialization:: *)
(************* Head and output form for generators of the Brauer algebra **********)
GeneratorPerm/:MakeBoxes[GeneratorPerm[i_Integer],StandardForm]:=SubscriptBox[UnderscriptBox["s","_"],MakeBoxes[i,StandardForm]];
MakeExpression[SubscriptBox[UnderscriptBox["s","_"],i_],StandardForm]:=MakeExpression[RowBox[{"GeneratorPerm","[",i,"]"}],StandardForm];
GeneratorTrace/:MakeBoxes[GeneratorTrace[i_Integer],StandardForm]:=SubscriptBox[UnderscriptBox["d","_"],MakeBoxes[i,StandardForm]];
MakeExpression[SubscriptBox[UnderscriptBox["d","_"],i_],StandardForm]:=MakeExpression[RowBox[{"GeneratorTrace","[",i,"]"}],StandardForm];


(* ::Input::Initialization:: *)
IdentityBrauer[n_]:=BrauerList[Drop[Thread[{Range[n],DownInteger[Range[n]]}]]];
IdentityBrauer[]:=GeneratorPerm[0];


(* ::Input::Initialization:: *)
(******** The up arc is between vertex i and vertex i+1 ; the down arc between vertex i+n and i+1+n *******)
TraceI[i_Integer,n_]:=With[{arcs={{i,i+1},{DownInteger[i],DownInteger[i+1]}}},BrauerList[Sort[Join[arcs,Drop[Thread[{Range[n],DownInteger[Range[n]]}],{arcs[[1,1]],arcs[[1,2]]}]]]]]
(******** The up arc is between vertex i and vertex j ; the down arc between vertex i+n and j+n : probably need to be optimized *******)
TraceIJ[i_Integer,j_Integer,n_]:=With[{arcs={{i,j},{DownInteger[i],DownInteger[j]}},idlines=Thread[{Range[n],DownInteger[Range[n]]}]},BrauerList[Sort[Join[arcs,DeleteCases[idlines,a_/;MemberQ[a,i]||MemberQ[a,j]]]]]]


(* ::Input::Initialization:: *)
(********* Multiple traces : needs to be optimized *********)
(******** The up arcs are between vertex i1,j1, ... in,jn *******)
TraceIJ[i_List,j_List,n_]:=With[{f=Length[i],arcs=Thread[List[i,j]],idlines=Thread[{Range[n],DownInteger[Range[n]]}]},BrauerList[Sort@Join[arcs,DeleteCases[idlines,a_/;IntersectingQ[a,i]||IntersectingQ[a,j]],DownInteger/@arcs]]]


(* ::Input::Initialization:: *)
(******** The crossing lines are the lines between vertex i, i+1+n and i+1, i+n  **********)
CycleI[i_Integer,n_]:=PermToBrauer[System`Cycles[{{i,i+1}}],n ]
(******************************************************************************************)
CycleIJ[i_Integer,j_Integer,n_]:=PermToBrauer[System`Cycles[{{i,j}}],n ];


(* ::Input::Initialization:: *)
Options[BrauerGenerators]:={SymmetricGroupOnly->False,Output->Symbol}
BrauerGenerators[n_Integer,options:OptionsPattern[]]:=Module[{range=Range[n-1],symgroupQ,output},
{symgroupQ,output}=OptionValue[{BrauerGenerators},{options},{SymmetricGroupOnly,Output}];
If[output==Symbol,
If[symgroupQ,Return[GeneratorPerm[#]&/@range,Module],Return[Join[GeneratorPerm[#]&/@range,GeneratorTrace[#]&/@range],Module]
]
];
If[symgroupQ,
Map[CycleI[#,n]&,range],
Join[Map[CycleI[#,n]&,range],Map[TraceI[#,n]&,range]
]
]
]


(* ::Input::Initialization:: *)
ToBrauerList0[GeneratorPerm[0],n_Integer]:=IdentityBrauer[n];
ToBrauerList0[si_GeneratorPerm,n_]:=CycleI[Sequence@@si,n];
ToBrauerList0[di_GeneratorTrace,n_]:=TraceI[Sequence@@di,n];


(* ::Input::Initialization:: *)
(************* Head and output form for Jucys-Murphys Elements **********)
JucysMurphyS/:MakeBoxes[JucysMurphyS[i_Integer],StandardForm]:=SubscriptBox[OverscriptBox["y","_"],MakeBoxes[i,StandardForm]];
MakeExpression[SubscriptBox[OverscriptBox["y","_"],i_],StandardForm]:=MakeExpression[RowBox[{"JucysMurphyS","[",i,"]"}],StandardForm];
JucysMurphyB/:MakeBoxes[JucysMurphyB[i_Integer],StandardForm]:=SubscriptBox[OverscriptBox["x","_"],MakeBoxes[i,StandardForm]];
MakeExpression[SubscriptBox[OverscriptBox["x","_"],i_],StandardForm]:=MakeExpression[RowBox[{"JucysMurphyB","[",i,"]"}],StandardForm];


(* ::Input::Initialization:: *)
Options[JucysMurphy]:={SymmetricGroupOnly->False,Output->Symbol}
JucysMurphy[n_,options:OptionsPattern[]]:=Module[{symgroupQ,output},
{symgroupQ,output}=OptionValue[{JucysMurphy},{options},{SymmetricGroupOnly,Output}];
If[output==Symbol,
If[symgroupQ,Return[Table[JucysMurphyS[i],{i,1,n}],Module],Return[Table[JucysMurphyB[i],{i,1,n}],Module]
]
];
If[symgroupQ,
Join[{0},Map[Sum[CycleIJ[j,#,n],{j,1,#-1}]&,Range[2,n]]]
,
Join[{0},Map[Sum[CycleIJ[j,#,n]-TraceIJ[j,#,n],{j,1,#-1}]&,Range[2,n]]]+(BrauerParameter[]-1)/2*IdentityBrauer[n]
]
]


(* ::Input::Initialization:: *)
ToBrauerList0[jm_JucysMurphyS,n_]:=With[{i=Sequence@@jm},Sum[CycleIJ[j,i,n],{j,1,i-1}]];
ToBrauerList0[jm_JucysMurphyB,n_]:=With[{i=Sequence@@jm},Sum[CycleIJ[j,i,n]-TraceIJ[j,i,n],{j,1,i-1}]+(BrauerParameter[]-1)/2*IdentityBrauer[n]];


(* ::Input::Initialization:: *)
(************ Relation between Jucys-Murphy elements and generators : M.Nazarov,Journal of Algebra 182,664 (1996).https://pure.york.ac.uk/portal/en/publications/youngs-orthogonal-form-for-brauers-centralizer-algebra ****************)
ToGeneratorsRule[jm_JucysMurphyB]:=jm:>RecurrenceTable[{JucysMurphyB[n+1]==(GeneratorPerm[n]-GeneratorTrace[n]+BrauerProduct[GeneratorPerm[n],JucysMurphyB[n],GeneratorPerm[n]]),JucysMurphyB[1]==(BrauerParameter-1)/2*GeneratorPerm[0]},JucysMurphyB,{n,{Sequence@@jm}}][[1]]
ToGenerators0[jm_JucysMurphyB]:=jm/. ToGeneratorsRule[jm]
ToGenerators[exp_]:=exp/.jm_JucysMurphyB:>ToGenerators0[jm];


(* ::Input::Initialization:: *)
ToBrauerList0[bracelets_Bracelets?(!SymmetricGroupQ[#]&)]:=ConjugacyClass[bracelets];
ToBrauerList0[ClassSum[bracelets_Bracelets]]:=ConjugacyClassSum[bracelets];
ToBrauerList0[ClassSum[\[Mu]_List]]:=ConjugacyClassSum[PartitionToBracelets[\[Mu]]];
ToBrauerList0[bracelets_Bracelets?(SymmetricGroupQ[#]&)]:=PermToBrauer[ConjugacyClass[bracelets],Length[Flatten@@bracelets]];
ToBrauerList[exp_,n_]:=exp/.x_BrauerCycles|x_GeneratorPerm|x_GeneratorTrace|x_JucysMurphyS|x_JucysMurphyB:>ToBrauerList0[x,n]
ToBrauerList[exp_]:=exp/.x_BrauerGraph|x_Bracelets|x_ClassSum:>ToBrauerList0[x]


(* ::Input::Initialization:: *)
BrauerParameter/:MakeBoxes[BrauerParameter,StandardForm]:=SubscriptBox["\[Delta]","b"];
MakeExpression[SubscriptBox[\[Delta]_,"b"],StandardForm]:=MakeExpression[RowBox[{"BrauerParameter"}],StandardForm];


(* ::Input::Initialization:: *)
BrauerParameter[]:=BrauerParameter;


(* ::Input::Initialization:: *)
SetBrauerParamaterTo[\[Delta]_]:=With[{},Unprotect[BrauerParameter];
BrauerParameter[]:=\[Delta];
$Scalars:=DeleteCases[DeleteDuplicates[{BrauerParameter,\[Delta]}],_Integer];
Protect[BrauerParameter];
];


(* ::Input::Initialization:: *)
(************* Taken from the xTensor Package ****************)
SetAttributes[interpretbox,HoldFirst];
interpretbox[expr_,box_]:=InterpretationBox[
StyleBox[box,AutoSpacing->False,ShowAutoStyles->False],
expr,
Editable->False
];
SetAttributes[MakeSequenceBox,HoldFirst];
MakeSequenceBox[list_List,char_,format_]:=RowBox@Riffle[Map[Function[Null,MakeBoxes[#,format],HoldFirst],Unevaluated[list]],char];


(* ::Input::Initialization:: *)
makeSupScriptString[x_,n_]:=ToExpression[StringJoin["\"\\!\\(\\*SubscriptBox[\\(",ToString[x],"\\), \\(",ToString[n],"\\)]\\)\""]]
(*MakeBoxes[BrauerProduct[{\[Delta]_?(#=!=BrauerParameter[]&)},factors__,options:OptionsPattern[]],StandardForm]:=interpretbox[BrauerProduct[{\[Delta]},factors],MakeSequenceBox[{factors},makeSupScriptString["\[CircleDot]",\[Delta]],StandardForm]];*)
MakeBoxes[BrauerProduct[{\[Delta]_},factors__,options:OptionsPattern[]],StandardForm]:=interpretbox[BrauerProduct[{\[Delta]},factors],MakeSequenceBox[{factors},"\[CircleDot]",StandardForm]];


(* ::Input::Initialization:: *)
BrauerProduct[arg1_?(!ListQ[#]&),args__,options:OptionsPattern[]]:=BrauerProduct[{BrauerParameter[]},arg1,args,options]


(* ::Input::Initialization:: *)
(*Verbatim[BrauerProduct][{\[Delta]_},exp_,options:OptionsPattern[]]:=exp;*)
BrauerProduct[{\[Delta]_},exp_,options:OptionsPattern[]]:=exp;
BrauerProduct[arg1_?(!ListQ[#]&),options:OptionsPattern[]]:=arg1;


(* ::Input::Initialization:: *)
(*SetAttributes[BrauerProduct,{Flat,OneIdentity}];*)
(**** Implementation of associativity with Attributes does not work here (or at least right away) because the product depends on a parameter ***)
BrauerProduct[{\[Delta]_},arg1_BrauerList,arg2_BrauerList,arg3__BrauerList]:=BrauerProduct[{\[Delta]},arg1,BrauerProduct[{\[Delta]},arg2,arg3]]


(* ::Input::Initialization:: *)
Verbatim[BrauerProduct][{\[Delta]_}]:=GeneratorPerm[0];
Verbatim[BrauerProduct][{\[Delta]_},left___,GeneratorPerm[0],right___,options:OptionsPattern[]]:=BrauerProduct[left,right,options]
Verbatim[BrauerProduct][{\[Delta]_},left___,System`Cycles[{}],right___,options:OptionsPattern[]]:=BrauerProduct[left,right,options]


(* ::Input::Initialization:: *)
BrauerProduct[{\[Delta]_},left___,0,right___,options:OptionsPattern[]]:=0;
BrauerProduct[{\[Delta]_},left___,sum_Plus,right___,options:OptionsPattern[]]:=BrauerProduct[{\[Delta]},left,#,right,options]&/@sum;
(********** SeriesDate To do *****************)
(*BrauerProduct[left___,sum_SeriesData,right___]:=SeriesDataMap[BrauerProduct[left,#,right]&,sum];*)


(* ::Input::Initialization:: *)
(****** We need to be able to check if an expression should be understood as a scalar expression.*********)
$Scalars:={BrauerParameter};
ScalarBrauerQ[d1_]:=MemberQ[$Scalars,d1];
ScalarBrauerQ[d1_?NumericQ]:=True;
ScalarExpressionForBrauerProductQ[exp_,\[Delta]_]:=NumericQ[exp]||(FreeQ[exp,a_Symbol/;(!MemberQ[Join[$Scalars,{\[Delta]}],a]),Heads->False]&&FreeQ[exp,_BrauerList|_GeneratorPerm|_GeneratorTrace|_JucysMurphyS|_JucysMurphyB|_System`Cycles])
BrauerProduct[{\[Delta]_},left___,k_*d1_,right___,options:OptionsPattern[]]/;TrueQ[ScalarExpressionForBrauerProductQ[k,\[Delta]]]:=k*BrauerProduct[{\[Delta]},left,d1,right,options]


(* ::Input::Initialization:: *)
(************* First set of rules ***********)
ruleReduceWord1:={BrauerProduct[{\[Delta]_},d1___,s1_GeneratorPerm,s1_GeneratorPerm,d2___]:>BrauerProduct[{\[Delta]},d1,d2],
BrauerProduct[{\[Delta]_},d1___,d0_GeneratorTrace,d0_GeneratorTrace,d2___]:>\[Delta]*BrauerProduct[{\[Delta]},d1,d0,d2],
BrauerProduct[{\[Delta]_},d1___,GeneratorTrace[i_],GeneratorPerm[i_],d2___]:>BrauerProduct[{\[Delta]},d1,GeneratorTrace[i],d2],
BrauerProduct[{\[Delta]_},d1___,GeneratorPerm[i_],GeneratorTrace[i_],d2___]:>BrauerProduct[{\[Delta]},d1,GeneratorTrace[i],d2]
}
(************* Second set of rules ***********)
ruleReduceWord2:={BrauerProduct[{\[Delta]_},d1___,GeneratorPerm[j_],GeneratorPerm[i_],GeneratorPerm[j_],d2___]/;j==i+1:>BrauerProduct[{\[Delta]},d1,GeneratorPerm[i],GeneratorPerm[i+1],GeneratorPerm[i],d2],
BrauerProduct[{\[Delta]_},d1___,GeneratorTrace[i_],GeneratorTrace[j_],GeneratorTrace[i_],d2___]/;j==i+1:>BrauerProduct[{\[Delta]},d1,GeneratorTrace[i],d2],BrauerProduct[{\[Delta]_},d1___,GeneratorTrace[j_],GeneratorTrace[i_],GeneratorTrace[j_],d2___]/;j==i+1:>BrauerProduct[{\[Delta]},d1,GeneratorTrace[i+1],d2],
BrauerProduct[{\[Delta]_},d1___,GeneratorPerm[i_],GeneratorTrace[j_],GeneratorTrace[i_],d2___]/;j==i+1:>BrauerProduct[{\[Delta]},d1,GeneratorPerm[i+1],GeneratorTrace[i],d2],
BrauerProduct[{\[Delta]_},d1___,GeneratorTrace[j_],GeneratorTrace[i_],GeneratorPerm[j_],d2___]/;j==i+1:>BrauerProduct[{\[Delta]},d1,GeneratorTrace[i+1],GeneratorPerm[i],d2]}
(***************** Third set of relations   ****************)
ruleReduceWord3:={BrauerProduct[{\[Delta]_},d1___,GeneratorPerm[i_],GeneratorPerm[j_],d2___]/;(i-j>1):>BrauerProduct[{\[Delta]},d1,GeneratorPerm[j],GeneratorPerm[i],d2],
BrauerProduct[{\[Delta]_},d1___,GeneratorTrace[i_],GeneratorPerm[j_],d2___]/;(i-j>1):>BrauerProduct[{\[Delta]},d1,GeneratorPerm[j],GeneratorTrace[i],d2],BrauerProduct[{\[Delta]_},d1___,GeneratorPerm[i_],GeneratorTrace[j_],d2___]/;(i-j>1):>BrauerProduct[{\[Delta]},d1,GeneratorTrace[j],GeneratorPerm[i],d2],
BrauerProduct[{\[Delta]_},d1___,GeneratorTrace[i_],GeneratorTrace[j_],d2___]/;(i-j>1):>BrauerProduct[{\[Delta]},d1,GeneratorTrace[j],GeneratorTrace[i],d2]}


(* ::Input::Initialization:: *)
(****************** All rules *************************)
ruleReduceWord:=Join[ruleReduceWord1,ruleReduceWord2,ruleReduceWord3]
ToReducedWord[exp_]:=exp//.ruleReduceWord


(* ::Input::Initialization:: *)
(******************* Permutations with Mathematica Cycles notation *****************)
BrauerProduct[{\[Delta]_},perm1_System`Cycles,perm2_System`Cycles,options:OptionsPattern[]]:=With[{convention=Sequence@@OptionValue[{BrauerProduct},{options},{ProductConvention}]},
If[convention===Below,PermutationProduct[perm2,perm1],PermutationProduct[perm1,perm2]]];
(*BrauerProduct[{\[Delta]_},perm1_System`Cycles,x:BrauerList[list_],options:OptionsPattern[]]:=With[{convention=Sequence@@OptionValue[{BrauerProduct},{options},{ProductConvention}],n=Length[list]},
If[convention===Below,
BrauerList[Sort[Map[Sort,Partition[PermutationReplace[Flatten[list],perm1],2],1]]],
BrauerList[Sort[Map[Sort,Partition[PermutationReplace[Flatten[list],InversePermutation[perm1]],2],1]]]
]
];
BrauerProduct[{\[Delta]_},x:BrauerList[list_],perm1_System`Cycles,options:OptionsPattern[]]:=With[{convention=Sequence@@OptionValue[{BrauerProduct},{options},{ProductConvention}],n=Length[list]},
If[convention===Above,
BrauerList[Sort[Map[Sort,Partition[PermutationReplace[Flatten[list],perm1],2],1]]],
BrauerList[Sort[Map[Sort,Partition[PermutationReplace[Flatten[list],InversePermutation[perm1]],2],1]]]
]
];*)
BrauerProduct[{\[Delta]_},perm1_System`Cycles,x:BrauerList[list_],options:OptionsPattern[]]:=With[{n=Length[list]},BrauerProduct[{\[Delta]},PermToBrauer[perm1,n],x,options]];
BrauerProduct[{\[Delta]_},x:BrauerList[list_],perm1_System`Cycles,options:OptionsPattern[]]:=With[{n=Length[list]},BrauerProduct[{\[Delta]},x,PermToBrauer[perm1,n],options]];


(* ::Input::Initialization:: *)
(*********************************************************)
(**************** The general product ********************)
(*********************************************************)
mycomplementSmall[list1_,list2_]:=Fold[DeleteCases[##,1,1]&,list1,list2] 
(** 1. The rule for product  ***)
rulesbrauerproduct={{a___,{u_,x_},b___,{v_,x_},c___}:>{a,{u,v},b,c},{a___,{x_,u_},b___,{x_,v_},c___}:>{a,{u,v},b,c},{a___,{x_,u_},b___,{v_,x_},c___}:>{a,b,{v,u},c},{a___,{u_,x_},b___,{x_,v_},c___}:>{a,{u,v},b,c}};
(** 2. The function taking care of loops and convention and sorting the product ***)
Options[BrauerProduct]:={ProductConvention->Below}
BrauerProduct[{\[Delta]_},BrauerList[list1_],BrauerList[list2_],options:OptionsPattern[]]:=Module[{arcs1,arcs2,proddiag0,proddiag,nloops,convention},
{convention}=OptionValue[{BrauerProduct},{options},{ProductConvention}];
If[convention===Below,
arcs1=Select[list1,ArcDownQ[#]&];
arcs2=Select[list2,ArcUpQ[#]&];
proddiag0=ReleaseHold[Join[Map[DownInteger,mycomplementSmall[list1,arcs1],{2}],mycomplementSmall[list2,arcs2]]//.rulesbrauerproduct],
arcs1=Select[list1,ArcUpQ[#]&];
arcs2=Select[list2,ArcDownQ[#]&];
proddiag0=ReleaseHold[Join[Map[DownInteger,mycomplementSmall[list2,arcs2],{2}],mycomplementSmall[list1,arcs1]]//.rulesbrauerproduct]
];
(***** Taking care of loops *****)
proddiag=DeleteCases[proddiag0,{a_,a_}];
nloops=Length[proddiag0]-Length[proddiag];
(**** We sort the list **********)
proddiag=\[Delta]^nloops*BrauerList[Sort[Join[arcs1,Sort/@proddiag,arcs2]]]
]


(* ::Input::Initialization:: *)
RowWord[stdTab_]:=Flatten[Reverse[stdTab]]
RowWordToTab[list_]:=Reverse[Split[list,Less]]
RemoveLetter[stdTab_,n_]:=RowWordToTab[DeleteCases[RowWord[stdTab],n]]
boxlist[\[Mu]_]:=Flatten[#,1]&@Table[{b,a},{b,1,Length[\[Mu]]},{a,1,\[Mu][[b]]}]
boxlist[\[Mu]_,\[Lambda]_]:=Complement[boxlist[\[Mu]],boxlist[\[Lambda]]]
(** See section 10.0 for the bratteli diagram of the symmetric group and of the Brauer algebra **)


(* ::Input::Initialization:: *)
(*(************** Old algorithm using BratteliPath and YoungSymmetrizer (not working anymore) ***********)
SemiNormalYoungUnitOld[sdtyoungtab_]:=Module[{brattelipath,listyoungop,smY,n=Length[Flatten@sdtyoungtab],listsmY},
brattelipath=BratteliPath[sdtyoungtab];
listyoungop=YoungSymmetrizer[#]&/@brattelipath;
smY=listyoungop[[2]];
listsmY={listyoungop[[2]]};
Do[
smY=PermutationProduct[smY,PermutationProduct[listyoungop[[zz]],smY]//Simplify]//Simplify;
AppendTo[listsmY,smY];
,{zz,3,n}];
Last@listsmY
];*)


(* ::Input::Initialization:: *)
(** New algorithm : construction in terms of Jucys-Murphy elements **)
(************* Manipulations with tableaux needed for the algorithm ****)
ContentCell[tab_,k_]:=First[Differences@@Position[tab,k]]
AddedCell[\[Mu]_,\[Lambda]_]:=Flatten[Complement@@(Reverse[boxlist[#]&/@{\[Mu],\[Lambda]}])]
AddableCells[\[Mu]_]:=Map[AddedCell@@#&,AppendStrictTableau[{\[Mu]},1]]
ContentAddableCells[\[Mu]_]:=Map[#[[2]]-#[[1]]&,AddableCells[\[Mu]]]
PartitionTruncate[p_]:=DeleteCases[p,0];
PartitionTruncate[p_]:=If[p=={}||p[[-1]]!=0,p,PartitionTruncate[Take[p,Length[p]-1]]];
PartitionLength[p_]:=Length[PartitionTruncate[p]]
PartitionStrictlyCompare[p_,q_]:=(IncludedPartitionQ[q,p]&&PartitionLength[q]<=PartitionLength[p]+1&&(And@@Table[p[[i]]==q[[i]]||q[[i+1]]<p[[i]]+1,{i,1,PartitionLength[q]-1}]))
AppendStrictTableau[t_,n_]:=(Append[t,#]&/@Select[IntegerPartitions[(Plus@@t[[-1]])+n],PartitionStrictlyCompare[t[[-1]],#]&])
(***********************************************************************)
(**************************** Memoization ******************************)
(***********************************************************************)
SemiNormalYoungUnit[{{1}},1]:=System`Cycles[{{}}]
SemiNormalYoungUnit[\[Mu]tab_,n_]:=SemiNormalYoungUnit[\[Mu]tab,n]=Module[{\[Mu]tabbar=RemoveLetter[\[Mu]tab,n],\[Mu]=Length/@\[Mu]tab,cTn=ContentCell[\[Mu]tab,n],setproduct},
setproduct=DeleteCases[ContentAddableCells[Length/@\[Mu]tabbar],cTn];
Expand[PermutationProduct[SemiNormalYoungUnit[\[Mu]tabbar,n-1],PermutationProduct@@Map[(Sum[System`Cycles[{{n,j}}],{j,1,n-1}]-#*System`Cycles[{{}}])/(cTn-#)&,setproduct]]]]
SemiNormalYoungUnit[\[Mu]tab_]:=SemiNormalYoungUnit[\[Mu]tab,Length[Flatten[\[Mu]tab]]]


(* ::Input::Initialization:: *)
(************ May cause some problem because we modify the Build-in function  PermutationProduct *********)
Unprotect[PermutationProduct];
PermutationProduct[perm1_,exp_Plus]:=PermutationProduct[perm1,#]&/@exp;
PermutationProduct[exp_Plus,perm1_]:=PermutationProduct[#,perm1]&/@exp;
PermutationProduct[Times[n1_?NumericQ ,perm1_],perm2_]:=n1*PermutationProduct[perm1,perm2];
PermutationProduct[perm1_,Times[n1_?NumericQ ,perm2_]]:=n1*PermutationProduct[perm1,perm2];
PermutationProduct[x_,y__Bracelets?(SymmetricGroupQ[#]&)]:=PermutationProduct[ConjugacyClassSum[x],Sequence@@(ConjugacyClassSum/@List[y])];
(*PermutationProduct[Times[n1_Symbol ,perm1_],perm2_]:=n1*PermutationProduct[perm1,perm2];
PermutationProduct[perm1_,Times[n1_Symbol,perm2_]]:=n1*PermutationProduct[perm1,perm2];*)
(***** Thread over list ****)
(*PermutationProduct[list_List,perm_System`Cycles]:=PermutationProduct[#,perm]&/@list;
PermutationProduct[perm_System`Cycles,list_List]:=PermutationProduct[perm,#]&/@list;*)
Protect[PermutationProduct];


(* ::Input::Initialization:: *)
(******** New alogrithm : faster used build-in functions *******)
RawSymmetrizer[stdtab_]:=Block[{n=Length[Flatten[stdtab]],sn,complementsLines},
sn=SymmetricGroup[n];
complementsLines=Complement[Range[n],#]&/@stdtab;
PermutationProduct@@Map[Plus@@#&,(GroupElements[#]&/@(GroupStabilizer[sn,#]&/@complementsLines))]]


(* ::Input::Initialization:: *)
(******** New alogrithm : faster used build-in functions *******)
ColumnAntisymmetrizer[stdtab_,options:OptionsPattern[]]:=Block[{n=Length[Flatten[stdtab]],tranpose=Flatten[stdtab,{{2},{1}}],sn,complementsColumns},
sn=SymmetricGroup[n];
complementsColumns=Complement[Range[n],#]&/@tranpose;
PermutationProduct@@Map[Plus@@#&,Map[SignatureBrauer[#]*#&,(GroupElements[#]&/@(GroupStabilizer[sn,#]&/@complementsColumns)),{2}]]]


(* ::Input::Initialization:: *)
TransposeTableau[tab_]:=Flatten[tab,{2}];


(* ::Input::Initialization:: *)
(****** Hook length formula ********)
HookLengthProduct[partition_]:=Times@@Flatten[Flatten[Reverse/@Range/@TransposePartition[partition],{2}]+Reverse/@Range/@partition-1];


(* ::Input::Initialization:: *)
NumberOfTableaux[partition_List]:=DimOfIrrepSn[partition]
NumberOfTableaux[n_Integer]:=Plus@@(DimOfIrrepSn[#]&/@IntegerPartitions[n])


(* ::Input::Initialization:: *)
(************* New algorithm *************)
Options[YoungSymmetrizerCycles]:={ManifestSym->Symmetric}
YoungSymmetrizerCycles[stdtab_,options:OptionsPattern[]]:=Block[{n=Length[Flatten[stdtab]],YS=RawSymmetrizer[stdtab],YA=ColumnAntisymmetrizer[stdtab],youngdiag=Length/@stdtab,msym},
{msym}=OptionValue[{YoungSymmetrizerCycles},{options},{ManifestSym}];
If[msym===Symmetric,
Expand[DimOfIrrepSn[youngdiag]/(n!)*PermutationProduct[YS,YA]],
Expand[DimOfIrrepSn[youngdiag]/(n!)*PermutationProduct[YA,YS]]]
];

Options[YoungSymmetrizer]:={Output->Cycles,ManifestSym->Symmetric}
YoungSymmetrizer[stdtab_,options:OptionsPattern[]]:=Module[{output,msym},
{output}=OptionValue[{YoungSymmetrizer},{options},{Output}];
{msym}=OptionValue[{YoungSymmetrizer},{options},{ManifestSym}];
If[SameQ[output,Cycles],
YoungSymmetrizerCycles[stdtab,ManifestSym->msym],
PermToBrauer[YoungSymmetrizerCycles[stdtab,ManifestSym->msym],Length[Flatten[stdtab]]]
]
];


(* ::Input::Initialization:: *)
Bracelets/:MakeBoxes[Bracelets[list_List],StandardForm]:=SubscriptBox[MakeBoxes[list,StandardForm],"\[EmptySmallCircle]"];
MakeExpression[SubscriptBox[b_,"\[EmptySmallCircle]"],StandardForm]:=MakeExpression[RowBox[{"Bracelets","[",b,"]"}],StandardForm];


(* ::Input::Initialization:: *)
BraceletForm0[cyclebracelet_List,r1_,r2_,colormapping_,imagesize_]:=With[{n=Length[cyclebracelet],colorlist=cyclebracelet/.colormapping},Graphics[{Circle[{0,0},r1],Map[{EdgeForm[Thickness[0.004]],#[[1]],Disk[#[[2]],r2]}&,Map[{#[[1]],r1 {-Cos[#[[2]]],-Sin[#[[2]]]}}&,Thread[List[Reverse@colorlist,2 \[Pi] Range[n]/n]]]]},ImageSize->imagesize]];
BraceletForm0[bracelet_Bracelets,r1_,r2_,colormapping_,imagesize_]:=With[{list=Sequence@@bracelet},Bracelets[Map[BraceletForm0[#,r1,r2,colormapping,imagesize]&,list]]];


(* ::Input::Initialization:: *)
Options[BraceletForm]:={ImageSize->42,ColorRules->{1->RGBColor[1, 0, 0],2->RGBColor[Rational[255, 256], Rational[87, 128], Rational[33, 128]],3->Black}}
BraceletForm[bracelet_Bracelets,options:OptionsPattern[]]:=Module[{imagesize,colorrule},
{imagesize,colorrule}=OptionValue[{BraceletForm},{options},{ImageSize,ColorRules}];
BraceletForm0[bracelet,1,0.18,colorrule,imagesize]
]
BraceletForm[k_*bracelet_Bracelets,options:OptionsPattern[]]:=k*BraceletForm[bracelet,options]
BraceletForm[exp_Plus,options:OptionsPattern[]]:=BraceletForm[#,options]&/@exp
BraceletForm[k_*exp_Plus,options:OptionsPattern[]]:=k*BraceletForm[exp,options]
BraceletForm[n_?NumericQ,options:OptionsPattern[]]:=n;


(* ::Input::Initialization:: *)
Gen0[0,x_Symbol]:=1/(1-x);
Gen0[n_Integer,x_Symbol]:=Module[{div=Divisors[n]},1/(2*(1-x^2)^n)+1/(2*n)*(Plus@@Map[EulerPhi[#]/((1-x^#)^(2*n/#))&,div])]
GendirCycles[nn_Integer,x_Symbol]:=Sum[Gen0[d,x]*x^(2d),{d,0,nn}];


(* ::Input::Initialization:: *)
DirCyclesSerie[n_Integer,x_Symbol]:=Normal@Series[GendirCycles[n,x],{x,0,n}];
DirectedCycleNum[1]:=1;
DirectedCycleNum[k_Integer/;k>1]:=(Last@DirCyclesSerie[k,x])[[1]];
\[Eta][q_Symbol,nn_Integer]:=Product[(1/(1-q^k))^DirectedCycleNum[k],{k,1,nn}];
NumberOfBracelets[1]:=1;
NumberOfBracelets[deg_Integer/;deg>1]:=(Last@Normal@Series[\[Eta][q,deg],{q,0,deg}])[[1]];


(* ::Input::Initialization:: *)
equivalentForms[nl_]:=Join[NestList[RotateLeft,nl,Length[nl]-1],NestList[RotateLeft,Reverse[nl],Length[nl]-1]];
canonicalFormC=Compile[{{list,_Integer,1}},Module[{l=NestList[RotateLeft,list,Length[list]-1]~Join~NestList[RotateLeft,Reverse[list],Length[list]-1]},Compile`GetElement[l,First[Ordering[l]]]],RuntimeAttributes->{Listable},Parallelization->True,CompilationTarget->"C",RuntimeOptions->"Speed"];
canonicalForm[list_?((SameQ@@#)&)]:=list;
canonicalForm[list_?(!(SameQ@@#)&)]:=canonicalFormC[list];
myDeleteDuplicateNecklaces[list_]:=DeleteDuplicates[Map[canonicalForm,list]];


(* ::Input::Initialization:: *)
SortBracelets[btab_Bracelets]:=BrauerCycleToBracelet[SortCycles1[BraceletToBrauerCycle[btab]]];
SortBracelets[btabsum_Plus]:=SortBracelets/@btabsum;
SortBracelets[Times[n_,btab_Bracelets]]:=n*SortBracelets[ btab];
SortBracelets[Times[n_,btabPlus_Plus]]:=n*SortBracelets[btabPlus];
SortBracelets[0]:=0;


ToCanonicalCycle[btab_Bracelets]:=Bracelets[{canonicalForm[btab[[1,1]]]}];
ToCanonicalCycle[btabs_Plus]:=Map[ToCanonicalCycle[#]&,btabs];
ToCanonicalCycle[Times[a_,btab_Bracelets]]:=a*ToCanonicalCycle[btab];
ToCanonicalCycle[Times[a_,btabs_Plus]]:=a*ToCanonicalCycle[btabs];
ToCanonicalCycle[0]:=0;

ToCanonicalBracelets[btab_Bracelets?(!SymmetricGroupQ[#]&&!CycleTabQ[#]&)]:=SortBracelets[Bracelets[canonicalForm/@(Sequence@@btab)]];
ToCanonicalBracelets[btab_Bracelets?(SymmetricGroupQ[#]&&CycleTabQ[#]&)]:=btab
ToCanonicalBracelets[btab_Bracelets?(SymmetricGroupQ[#]&&!CycleTabQ[#]&)]:=SortBracelets[btab]
ToCanonicalBracelets[btab_Bracelets?(!SymmetricGroupQ[#]&&CycleTabQ[#]&)]:=ToCanonicalCycle[btab]
ToCanonicalBracelets[btabs_Plus]:=Plus@@Map[ToCanonicalBracelets[#]&,List@@btabs];
ToCanonicalBracelets[Times[a_,btab_Bracelets]]:=a*ToCanonicalBracelets[btab];
ToCanonicalBracelets[Times[a_,btabs_Plus]]:=a*ToCanonicalBracelets[btabs];


(* ::Input::Initialization:: *)
ListSumIndices[m_Integer,n_Integer]:=Flatten[Permutations/@IntegerPartitions[n,{m},Join[{0},Range[n]]],1]
myIntegerPartition[m_Integer,n_Integer]:=Sort/@IntegerPartitions[n,{m},Range[0,n]];


(* ::Input::Initialization:: *)
equivalentFormsList[list_]:=Join[NestList[RotateLeft[#,2]&,list,Length[list]/2-1],NestList[RotateLeft[#,2]&,Reverse[list],Length[list]/2-1]];
canonicalFormList=Compile[{{list,_Integer,1}},Module[{l=NestList[RotateLeft[#,2]&,list,Length[list]/2-1]~Join~NestList[RotateLeft[#,2]&,Reverse[list],Length[list]/2-1]},Compile`GetElement[l,First[Ordering[l]]]],RuntimeAttributes->{Listable},Parallelization->True,CompilationTarget->"C",RuntimeOptions->"Speed"];
myDeleteDuplicateNecklacesList[list_]:=DeleteDuplicates[Map[canonicalFormList,list]];


(* ::Input::Initialization:: *)
ListSumIndicesCanonical0[m_Integer,n_Integer]:=Flatten[Map[If[Part[#,-2]=!=0,GroupOrbits[GroupStabilizer[SymmetricGroup[m],{1}],{#},Permute],{{#}}]&,myIntegerPartition[m,n]],2];


(* ::Input::Initialization:: *)
ListSumIndicesCanonical[m_Integer?(#<4&),n_Integer]:=myIntegerPartition[m,n];
ListSumIndicesCanonical[m_Integer?(#>3&),n_Integer]:=myDeleteDuplicateNecklacesList@ListSumIndicesCanonical0[m,n];


(* ::Input::Initialization:: *)
CyclesListCanonical[n_Integer,narcs_Integer]:=ListSumIndicesCanonical[2*narcs,n-2*narcs];
CyclesListCanonical[n_Integer]:=Module[{narcslist=Range[IntegerPart[n/2]]},Partition[Flatten[CyclesListCanonical[n,#]&/@narcslist,1],1]];
CyclesListCanonical[n_Integer,0]:={{n}};


(* ::Input::Initialization:: *)
SymmetricCycleQ[list_List?(Depth[#]===2&)]:=Length[list]==1;
SymmetricCycleQ[list_List?(Depth[#]===3&)]:=AllTrue[list,SymmetricCycleQ]


(* ::Input::Initialization:: *)
BrauerCycleToBracelet0[list_?SymmetricCycleQ]:=ConstantArray[3,list];
BrauerCycleToBracelet0[list_?(!SymmetricCycleQ[#]&)]:=Flatten[Map[Join[{1},ConstantArray[3,#[[1]]],{2},ConstantArray[3,#[[2]]]]&,Partition[list,2]]];
BrauerCycleToBracelet[list_]:=Bracelets[BrauerCycleToBracelet0/@list];


(* ::Input::Initialization:: *)
SelectShapes[list_List,n_Integer]:=Select[list,Length[#]<=n&];
SortCycles1[list_List?(Length[#]>1&)]:=SortBy[SortBy[list,-Length[#]&],-Total[Evaluate[#+2]]&];
SortCycles1[list_List?(Length[#]==1&)]:=list;


(* ::Input::Initialization:: *)
BrauerCycles[1]={{{1}}};
BrauerCycles[1,0]={{{1}}};
BrauerCycles[n_Integer,0]:=Partition[#,1]&/@IntegerPartitions[n];(*** Symmetric group cycles ***)
BrauerCycles[2]={{{2}},{{1},{1}},{{0,0}}};
BrauerCycles[2,0]={{{2}},{{1},{1}}};
BrauerCycles[2,1]={{{0,0}}};
(***** Precomputed Cycles *****)
BrauerCycles[3]=Evaluate[DeleteDuplicates[SortCycles1/@Join[{{{3}}},Flatten[Map[Flatten[Outer[Join[#1,#2,1]&,BrauerCycles[#[[1]]],BrauerCycles[#[[2]]],1],1]&,Rest@IntegerPartitions[3,2]],1],CyclesListCanonical[3]]]];
BrauerCycles[4]=Evaluate[DeleteDuplicates[SortCycles1/@Join[{{{4}}},Flatten[Map[Flatten[Outer[Join[#1,#2,1]&,BrauerCycles[#[[1]]],BrauerCycles[#[[2]]],1],1]&,Rest@IntegerPartitions[4,2]],1],CyclesListCanonical[4]]]];

BrauerCycles[n_Integer?(#>4&)]:=BrauerCycles[n]=Module[{intpart2=Rest@IntegerPartitions[n,2],listbcycles},
listbcycles=Map[If[#[[1]]<(2*n)/3,{Join[{{{#[[1]]}}},CyclesListCanonical[#[[1]]]],Join[{{{#[[2]]}}},CyclesListCanonical[#[[2]]]]},If[#[[1]]==n-1,{BrauerCycles[#[[1]]],BrauerCycles[#[[2]]]},{SelectShapes[BrauerCycles[#[[1]]],IntegerPart[#[[1]]/2]],Join[{{{#[[2]]}}},CyclesListCanonical[#[[2]]]]}]]&,intpart2];
DeleteDuplicates[SortCycles1/@Join[{{{n}}},Flatten[Map[Flatten[Outer[Join[#1,#2,1]&,#[[1]],#[[2]],1],1]&,listbcycles],1],CyclesListCanonical[n]]]];

BrauerCycles[nbrauer_Integer,1]:=DeleteDuplicates[SortCycles1/@Join[Flatten[Map[Flatten[Outer[Join[#1,#2,1]&,Split@CyclesListCanonical[#[[1]],1],BrauerCycles[#[[2]],0],1],1]&,Flatten[Permutations/@(Rest@IntegerPartitions[nbrauer,2]),1]],1],Split@CyclesListCanonical[nbrauer,1]]];

BrauerCycles[nbrauer_Integer,narcs_Integer]:=BrauerCycles[nbrauer,narcs]=Module[{res,listshapes
},
With[{listIntPartnbrauer=Select[Rest@IntegerPartitions[nbrauer,2],Plus@@{IntegerPart[#[[1]]/2],IntegerPart[#[[2]]/2]}>= narcs&],
listIntPartnarccs=Flatten[Permutations/@(myIntegerPartition[2,narcs]),1]
},
If[narcs>IntegerPart[nbrauer/2],res=Null,
listshapes=DeleteCases[Flatten[Outer[List[#1,#2]&,listIntPartnbrauer,listIntPartnarccs,1],1],{{a0_,a1_},{b0_,b1_}}/;b0>IntegerPart[a0/2]||b1>IntegerPart[a1/2]];
res=Join[DeleteDuplicates[SortCycles1/@Flatten[Map[Flatten[Outer[Join[#1,#2]&,#[[1]],#[[2]],1],1]&,Map[Thread[BrauerCycles[#[[1]],#[[2]]]]&,listshapes]],1]],Split@CyclesListCanonical[nbrauer,narcs]]
]
];
Return[res,Module]
]


(* ::Input::Initialization:: *)
Options[BrauerBracelets]:={SymmetricGroup->True}
BrauerBracelets[n_Integer,options:OptionsPattern[]]:=Module[{symQ,res},
{symQ}=OptionValue[{BrauerBracelets},{options},{SymmetricGroup}];
If[symQ,res=SortBy[BrauerCycleToBracelet/@BrauerCycles[n],Narcs[#]||-Length[Sequence@@#]&],
res=SortBy[Select[BrauerCycleToBracelet/@BrauerCycles[n],MemberQ[Flatten@@#,1]&],Narcs[#]||-Length[Sequence@@#]&]];
Return[res,Module]
];
BrauerBracelets1[n_Integer,narcs_Integer]:=SortBy[BrauerCycleToBracelet/@BrauerCycles[n,narcs],-Length[Sequence@@#]&]

BrauerBracelets[n_Integer,narcs_Integer]:=Module[{res},
If[narcs==0,
res=Bracelets/@Map[Map[ConstantArray[3,#]&,#]&,IntegerPartitions[n]],
If[narcs==1,
res=BrauerBracelets1[n,narcs],
If[n>10 && narcs >IntegerPart[n/2]-1,
res=BrauerBracelets1[n,narcs],
If[n>14 && narcs >IntegerPart[n/2]-2,
res=BrauerBracelets1[n,narcs],res=Select[BrauerBracelets[n],Count[Flatten[Sequence@@#],3]==n-2*narcs&]]]]];
Return[res,Module]
];
BrauerBracelets[n_Integer,n1_,n2_]:=Flatten[Map[BrauerBracelets[n,Sequence@@#]&,Range[n1,n2]]]


(* ::Input::Initialization:: *)
(** associativity **)
SetAttributes[MergeBrauer,{Flat,OneIdentity}];
(** one argument **)
Verbatim[MergeBrauer][exp_]:=exp;
(************* Distributivity ************)
MergeBrauer[left___,0,right___]:=0;
MergeBrauer[left___,sum_Plus,right___]:=MergeBrauer[left,#,right]&/@sum;
(*************** Linearity *****************)
MergeBrauer[left___,k_*d1_BrauerList,right___]:=k*MergeBrauer[left,d1,right];
(*************** action on two diagrams *****************)
MergeBrauer[x1:BrauerList[list1_],x2:BrauerList[list2_]]:=With[{n1=Length[list1],n2=Length[list2]},
BrauerList[Sort[Join[list1,list2/.{k_Integer:>k+n1,DownInteger[k_]:>DownInteger[k+n1]}]]]
]


(* ::Input::Initialization:: *)
LetterToEdge[1,{list_,edges_}]:=With[{k1=list[[1,1]],k2=list[[1,2]]},{DeleteCases[list,k1|k2,2],Join[edges,{{k1,k2}}]}]
LetterToEdge[3,{list_,edges_}]:=With[{k1=list[[1,1]],k2=list[[2,1]]},{DeleteCases[list,k1|k2,2],Join[edges,{{k1,k2}}]}]
LetterToEdge[2,{list_,edges_}]:=With[{k1=list[[2,1]],k2=list[[2,2]]},{DeleteCases[list,k1|k2,2],Join[edges,{{k1,k2}}]}]
LetterToEdgeLast[2,{list_,edges_}]:=With[{k1=list[[2,1]],k2=list[[2,2]]},{DeleteCases[list,k1|k2,2],Join[edges,{{k2,k1}}]}]
BraceletListToEdge[{bralist_,list_,edges_}]:=If[bralist[[1]]===1,Join[{Rest[bralist]},LetterToEdge[1,{list,edges}]],If[bralist[[1]]===3,Join[{Rest[bralist]},LetterToEdge[3,{list,edges}]],If[Length[bralist]===1,Join[{Rest[bralist]},LetterToEdgeLast[2,{list,edges}]],Join[{Rest[bralist]},LetterToEdge[2,{list,edges}]]]]];
(********* Representative for a full cycle ********)
OneCycleBraceletRepresentative[list_,n_]:=With[{support={Range[n],RotateLeft[DownInteger@Range[n]]}},BrauerList[Nest[BraceletListToEdge,{list,support,{}},n][[3]]]]
(********* Merging representative for all cycles in the bracelets ***)
ToRepresentativeDiagram[Bracelets[list_]]:=Sort/@(MergeBrauer@@Map[OneCycleBraceletRepresentative[#,Length[#]]&,list])


(* ::Input::Initialization:: *)
ToLoopBrauerList[BrauerList[list_],n_]:=BrauerList[Union[list,Thread[List[Range[n],DownInteger[Range[n]]]]]];
(* Ray Koopman https://mathematica.stackexchange.com/questions/37249/how-to-split-list-into-disjoint-lists *)
CollectIntersectingSublist[list_]:=Module[{j,aj},list[[#]]&/@SparseArray`StronglyConnectedComponents[Sign[# . Transpose@#&@SparseArray@Thread[Join@@(Function[{j,aj},{j,#}&/@Union@aj]@@@Transpose@{Range@Length@list,list/. Thread[#->Range@Length@#]&@Union@Flatten@list})->1]]]];
CollectIntersectingSublist[BrauerList[list_]]:=CollectIntersectingSublist[list];
ToDisjointCycles[x:BrauerList[list_],n_]:=Map[Select[#,MemberQ[list,#]&]&,CollectIntersectingSublist[ToLoopBrauerList[x,n]]]
ToDisjointCyclesForBrauerCycles[x:BrauerList[list_],n_]:=DeleteCases[Map[Select[#,MemberQ[list,#]&]&,CollectIntersectingSublist[ToLoopBrauerList[x,n]]],_?(Length@#==1&)]
(************ Canonical ordering of the cycles *********************)
SelectNextPair0[list_]:={Rest[list],{list[[1]]},ChangeInteger[list[[1,2]]]}
SelectNextPair[{list_,sortlist_,k_}]:=With[{l=Select[list,MemberQ[#,k]&]},{Complement[list,l],Join[sortlist,l],ChangeInteger@@DeleteCases[Flatten[l],k]}]
ToCyclesOrder0[list_]:=Nest[SelectNextPair,SelectNextPair0[list],Length[list]-1][[2]];
ToCyclesOrder[x:BrauerList[list_]]:=ToCyclesOrder0/@ToDisjointCycles[x,Length[list]];
(************* Rule to Bracelets ****************)
ToBraceletsRules={x_?ArcUpQ:>1,x_?ArcDownQ:>2,y_?LineQ:>3};
ToBracelets0[x:BrauerList[list_]]:=ToCanonicalBracelets[Bracelets[ToCyclesOrder[x]/.ToBraceletsRules]];
ToBracelets[exp_]:=exp/.x:BrauerList[list_]:>ToBracelets0[x]


(* ::Input::Initialization:: *)
SymGroupQ[btablist_]:=Equal@@btablist;


(* ::Input::Initialization:: *)
BraceletToBrauerCycleList[btablist_?SymGroupQ]:={Length[btablist]};
BraceletToBrauerCycleList[btablist_List?(SymGroupQ[#]===False&)]:=Flatten[Map[#[[2]]-(#[[1]]+1)&,Partition[Partition[Sort[Flatten[{Append[Position[btablist,1],Length[btablist]+1],Position[btablist,2]}]],2,1],2]],1]
BraceletToBrauerCycle[btab_Bracelets]:=Map[BraceletToBrauerCycleList[#]&,Sequence@@btab];


(* ::Input::Initialization:: *)
StabilityIndexList[list_]:=If[Length[list]>1,Count[Join[{Reverse@list},Rest[NestList[RotateLeft[#,2]&,list,Length[list]/2-1]],Reverse/@Rest[NestList[RotateLeft[#,2]&,list,Length[list]/2-1]]],list]+1,Sequence@@list];
StabilityIndex0[btab_Bracelets]:=Times@@Map[StabilityIndexList[#]&,BraceletToBrauerCycle[btab]];
StabilityIndex1[btab_Bracelets]:=Times@@Map[Length[#]!&,Gather[Sequence@@btab,SameQ]]
StabilityIndex[btab_Bracelets]:=StabilityIndex0[btab]*StabilityIndex1[btab];
StabilityIndex[btab_Bracelets?SymmetricGroupQ]:=StabilityIndex[BraceletsToPartition[btab]]
StabilityIndex[\[Mu]_]:=Times@@Map[#[[1]]^Length[#]*Length[#]!&,Split[\[Mu]]]
(*** Another solution a bit slower ***)
StabilityIndexOld[list_]:=Times@@Map[#[[1]]^#[[2]]*#[[2]]!&,Tally[list]]


(* ::Input::Initialization:: *)
RenormalizeClass[btab_Bracelets]:=StabilityIndex[btab]*btab;
RenormalizeClass[bplus_Plus]:=Map[RenormalizeClass[#]&,bplus];
RenormalizeClass[Times[a__,btab_Bracelets]]:=a*RenormalizeClass[btab];
RenormalizeClass[Times[a__,exp_Plus]]:=a*RenormalizeClass[exp];

NormalizeClass[btab_Bracelets]:=1/StabilityIndex[btab]*btab;
NormalizeClass[bplus_Plus]:=Map[NormalizeClass[#]&,bplus];
NormalizeClass[Times[a__,btab_Bracelets]]:=a*NormalizeClass[btab];
NormalizeClass[Times[a__,exp_Plus]]:=a*NormalizeClass[exp];

(********** Thread over list : maybe not needed **********)
RenormalizeClass[list_List]:=RenormalizeClass[#]&/@list;
RenormalizeClass[0]:=0;


(* ::Input::Initialization:: *)
(*****************************************************************************************************************)
(**************************** When the brauer diagram is a permutation we use GroupOrbits ************************)
(*****************************************************************************************************************)
ConjugacyClassPerm0[blist_,n_]:=Flatten[GroupOrbits[SymmetricGroup[n],{BrauerToPerm[blist]}]];
(*ConjugacyClassPerm[blist_,n_]:=PermToBrauer[#,n]&/@ConjugacyClassPerm0[blist,n];*)
ConjugacyClassPerm[blist_,n_]:=ConjugacyClassPerm0[blist,n];
ConjugacyClassPerm[blist_]:=ConjugacyClassPerm[blist,Length@@blist];

(*****************************************************************************************************************)
(***** When the brauer diagram is a not a permuation we use brut force conjugation : need to delete duplicate ****)
(*****************************************************************************************************************)

(**** I find this solution more pleasant but it is a bit slower so I keep it private ****)
ConjugacyClassPermutationGroup[Brauerlist_BrauerList]:=Block[{d=Sequence@@Brauerlist,n,gr},
n=Length[d];
BrauerList/@DeleteDuplicates[Map[Sort,Partition[#,2]&/@Permute[Flatten[d],PermutationGroup[Map[System`Cycles[{{#,#+1},{#+n,#+1+n}}]&,Range[n-1]]]],2]]
];

ConjugacyClass[blist_BrauerList,n_]:=Block[{range=Range[n],grp},
grp=System`Cycles/@MapThread[Flatten[Join[#1,#2],1]&,{List@@@PermutationCycles/@Permutations[range],List@@@PermutationCycles/@(Join[range,#]&/@Permutations[range+n])}];
BrauerList/@DeleteDuplicates[Map[Sort,Partition[#,2]&/@PermutationReplace[Flatten@@blist,grp],2]]
];
ConjugacyClass[blist_BrauerList]:=ConjugacyClass[blist,Length@@blist]
ConjugacyClass[blist_BrauerList?SymmetricGroupQ]:=ConjugacyClassPerm[blist];
(*** Input Bracelets ***)
ConjugacyClass[brauertab_Bracelets]:=ConjugacyClass[ToRepresentativeDiagram@brauertab];


(* ::Input::Initialization:: *)
ConjugacyClassSum0[d_Bracelets|d_BrauerList]:=Plus@@ConjugacyClass[d];
ConjugacyClassSum[exp_]:=exp/.d_Bracelets|d_BrauerList:>ConjugacyClassSum0[d];


(* ::Input::Initialization:: *)
ClassSum/:MakeBoxes[ClassSum[i_List],StandardForm]:=SubscriptBox["K",MakeBoxes[i,StandardForm]];
MakeExpression[SubscriptBox["K",i_],StandardForm]:=MakeExpression[RowBox[{"ClassSum","[",i,"]"}],StandardForm];
ClassSum/:MakeBoxes[ClassSum[i_Bracelets],StandardForm]:=SubscriptBox["K",MakeBoxes[i,StandardForm]];
MakeExpression[SubscriptBox["K",i_],StandardForm]:=MakeExpression[RowBox[{"ClassSum","[",i,"]"}],StandardForm];


(* ::Input::Initialization:: *)
CentralYoung/:MakeBoxes[CentralYoung[i_List],StandardForm]:=SubscriptBox[OverscriptBox["Z","_"],MakeBoxes[i,StandardForm]];
MakeExpression[SubscriptBox[OverscriptBox["Z","_"],i_],StandardForm]:=MakeExpression[RowBox[{"CentralYoung","[",i,"]"}],StandardForm];


(* ::Input::Initialization:: *)
SimplifyCentralYoungRule={ConjugacyClassProduct[delta_][left___,CentralYoung[list1_],CentralYoung[list1_],right___]:>ConjugacyClassProduct[delta][left,CentralYoung[list1],right],ConjugacyClassProduct[delta_][left___,CentralYoung[list1_],CentralYoung[list2_],right___]/;(Plus@@list1==Plus@@list2&&list1=!=list2):>0};
SimplifyCentralYoung0[exp_]:=exp/.SimplifyCentralYoungRule
SimplifyCentralYoung[exp_]:=FixedPoint[SimplifyCentralYoung0,exp]
(************ generate the list of central Young in Sn**********)
CentralYoung[n_Integer]:=CentralYoung/@IntegerPartitions[n]


(* ::Input::Initialization:: *)
ExpandCentralYoung0[x:CentralYoung[list_]]:=CentralYoungProjector[list]
ExpandCentralYoung0[x:CentralYoung[list_],n_]:=PermToBrauer[ConjugacyClassSum[CentralYoungProjector[list]]//Expand,n]
ExpandCentralYoung[exp_]:=exp/.x:CentralYoung[list_]:>ExpandCentralYoung0[x]
ExpandCentralYoung[exp_,n_]:=exp/.x:CentralYoung[list_]:>ExpandCentralYoung0[x,n]


(* ::Input::Initialization:: *)
(********** Central Young projector in terms of Conjugacy class of the symmetric group  ********)
(******************* See for example : Primitive Idempotents in Group Algebras : G.J.Janusz,Proceedings of the American Mathematical Society 17,520 (1966) ************************)
PartitionToBracelets[list_]:=Bracelets[ConstantArray[3,#]&/@list]
BraceletsToPartition[bracelets_]:=Length/@Sequence@@bracelets
CentralYoungProjector[list_]:=With[{n=Plus@@list,hl=HookLengthProduct[list]},Plus@@Map[1/hl*CharacterSymmetricGroup[list,#]*PartitionToBracelets[#]&,IntegerPartitions[n]]]
CentralYoungProjector[bracelets_Bracelets]:=CentralYoungProjector[BraceletsToPartition[bracelets]]


(* ::Input::Initialization:: *)
BraceletsToCentralYoung0[x:Bracelets[list_]?SymmetricGroupQ]:=Module[{\[Mu]=Length/@list,stab},
stab=StabilityIndex[\[Mu]];Plus@@Map[1/stab*HookLengthProduct[#]* CharacterSymmetricGroup[#,\[Mu]]*CentralYoung[#]&,IntegerPartitions[Plus@@\[Mu]]]]
BraceletsToCentralYoung[exp_]:=exp/.x:Bracelets[list_]:>BraceletsToCentralYoung0[x]


(* ::Input::Initialization:: *)
(*MakeBoxes[ConjugacyClassProduct[{\[Delta]_?(#=!=BrauerParameter[]&)},factors__,options:OptionsPattern[]],StandardForm]:=interpretbox[ConjugacyClassProduct[{\[Delta]},factors],MakeSequenceBox[{factors},makeSupScriptString["\[Diamond]",\[Delta]],StandardForm]];*)
MakeBoxes[ConjugacyClassProduct[{\[Delta]_},factors__,options:OptionsPattern[]],StandardForm]:=interpretbox[ConjugacyClassProduct[{\[Delta]},factors],MakeSequenceBox[{factors},"\[Diamond]",StandardForm]];


(* ::Input::Initialization:: *)
ConjugacyClassProduct[arg1_?(!ListQ[#]&),args__,options:OptionsPattern[]]:=ConjugacyClassProduct[{BrauerParameter[]},arg1,args,options]


(* ::Input::Initialization:: *)
(*Verbatim[ConjugacyClassProduct][{\[Delta]_},exp_,options:OptionsPattern[]]:=exp;*)
ConjugacyClassProduct[{\[Delta]_},exp_,options:OptionsPattern[]]:=exp;
ConjugacyClassProduct[arg1_?(!ListQ[#]&),options:OptionsPattern[]]:=arg1;


(* ::Input::Initialization:: *)
(*SetAttributes[ConjugacyClassProduct,{Flat,OneIdentity}];*)
(**** Implementation of associativity with Attributes does not work here (or at least right away) because the product depends on a parameter ***)
ConjugacyClassProduct[{\[Delta]_},arg1_BrauerList,arg2_BrauerList,arg3__BrauerList]:=ConjugacyClassProduct[{\[Delta]},arg1,ConjugacyClassProduct[{\[Delta]},arg2,arg3]]


(* ::Input::Initialization:: *)
Verbatim[ConjugacyClassProduct][{\[Delta]_},left___,id_?IdClassQ,right___,options:OptionsPattern[]]:=ConjugacyClassProduct[{\[Delta]},left,right]


(* ::Input::Initialization:: *)
ConjugacyClassProduct[{\[Delta]_},left___,0,right___,options:OptionsPattern[]]:=0;
ConjugacyClassProduct[{\[Delta]_},left___,sum_Plus,right___,options:OptionsPattern[]]:=ConjugacyClassProduct[{\[Delta]},left,#,right]&/@sum;
(********** SeriesDate To do *****************)
(*ConjugacyClassProduct[left___,sum_SeriesData,right___]:=SeriesDataMap[ConjugacyClassProduct[left,#,right]&,sum];*)


(* ::Input::Initialization:: *)
(****** We need to be able to check if an expression should be understood as a scalar expression.*********)
$Scalars:={BrauerParameter};
ScalarBrauerQ[d1_]:=MemberQ[$Scalars,d1];
ScalarBrauerQ[d1_?NumericQ]:=True;
ScalarExpressionQ[exp_]:=NumericQ[exp]||(MemberQ[Map[!FreeQ[exp,#,Heads->False]&,$Scalars],True]&&FreeQ[exp,a_Symbol/;(!MemberQ[$Scalars,a]),Heads->False]&&FreeQ[exp,_BrauerList|_GeneratorPerm|_GeneratorTrace|_System`Cycles])


(* ::Input::Initialization:: *)
(****** We need to be able to check if an expression should be understood as a scalar expression.*********)
$Scalars:={BrauerParameter};
ScalarBrauerQ[d1_]:=MemberQ[$Scalars,d1];
ScalarBrauerQ[d1_?NumericQ]:=True;
ScalarExpressionForConjugacyClassProductQ[exp_,\[Delta]_]:=NumericQ[exp]||(FreeQ[exp,a_Symbol/;(!MemberQ[Join[$Scalars,{\[Delta]}],a]),Heads->False]&&FreeQ[exp,_Bracelets|_CentralYoung])
ConjugacyClassProduct[{\[Delta]_},left___,k_*d1_,right___,options:OptionsPattern[]]/;TrueQ[ScalarExpressionForConjugacyClassProductQ[k,\[Delta]]]:=k*ConjugacyClassProduct[{\[Delta]},left,d1,right]


(* ::Input::Initialization:: *)
TClassQ[nt_,bracelet_Bracelets]:=With[{\[Mu]=BraceletsToPartition[bracelet]},Max[\[Mu]]===2&&Count[\[Mu],2]==nt];
TClass[n_,nt_]:=Bracelets[{Sequence@@ConstantArray[{3,3},nt],Sequence@@ConstantArray[{3},n-2nt]}]
TClass[n_,0]:=IdClass[n]
IdClass[n_]:=Bracelets[ConstantArray[{3},n]]
IdClassQ[bracelets_Bracelets]:=With[{\[Mu]=BraceletsToPartition[bracelets]},Max[\[Mu]]===1];


(* ::Input::Initialization:: *)
(********** Necessary conditions for zero connection coefficient : see for example Content evaluation and class symmetric functions : S. Corteel A. Goupil and G. Schaeffer ********************)
ToReducedPartition[\[Mu]_]:=DeleteCases[\[Mu]-1,0]
SameParityQ[n1_,n2_]:=(EvenQ[n1]&&EvenQ[n2])||(OddQ[n1]&&OddQ[n2])
(******** The last condition is not coded yet : refinement order on partitions ***********)
ConditionZeroConnectionCoefficient[redpart1_,redpart2_]:=!SameParityQ[Plus@@redpart1+Plus@@redpart2,Plus@@ToReducedPartition[#]]||(Plus@@ToReducedPartition[#])>(Plus@@redpart1+Plus@@redpart2)&

(******* Coefficient in the sum of classes resulting from the product are called connection coefficient **********)
ConnectionCoefficientsClassProductSym[partition1_,partition2_,n_]:=With[{st1=StabilityIndex[partition1],st2=StabilityIndex[partition2],redpart1=ToReducedPartition[partition1],redpart2=ToReducedPartition[partition2],partitions=IntegerPartitions[n],id=ConstantArray[1,n]},
n!/(st1*st2)*Map[If[ConditionZeroConnectionCoefficient[redpart1,redpart2][#],0,Sum[CharacterSymmetricGroup[partitions[[i]],partition1]*CharacterSymmetricGroup[partitions[[i]],partition2]*CharacterSymmetricGroup[partitions[[i]],#]/CharacterSymmetricGroup[partitions[[i]],id],{i,1,Length[partitions]}]]&,partitions]
]
ConnectionCoefficientsClassProductSym[partition1_,partition2_]:=ConnectionCoefficientsClassProductSym[partition1,partition2,Plus@@partition1]


(* ::Input::Initialization:: *)
ConjugacyClassProductSym[btab1_,btab2_,n_]:=BrauerBracelets[n,0] . ConnectionCoefficientsClassProductSym[Length/@(Sequence@@btab1),Length/@(Sequence@@btab2),n]
ConjugacyClassProductSym[btab1_,btab2_]:=ConjugacyClassProductSym[btab1,btab2,Length[Flatten@@btab1]]


(* ::Input::Initialization:: *)
ConjugacyClassProduct[{\[Delta]_},tab1_Bracelets?(SymmetricGroupQ[#]&&!TClassQ[1,#]&),tab2_Bracelets?(SymmetricGroupQ[#]&&!TClassQ[1,#]&)]:=ConjugacyClassProductSym[tab1,tab2]


(* ::Input::Initialization:: *)
(********* Not used for the moment **********)
SizeOfConjugacyClass[btab_Bracelets]:=With[{n=Length[Flatten@@btab]},
n!/StabilityIndex[btab]
]


(* ::Input::Initialization:: *)
ConjugacyClassProduct[{\[Delta]_},btab1_Bracelets?(!AClassQ[1,#]&&!TClassQ[1,#]&&!IdClassQ[#]&),btab2_Bracelets?(!AClassQ[1,#]&&!TClassQ[1,#]&&!IdClassQ[#]&)]:=Module[{rep1=ToRepresentativeDiagram[btab1],rep2=ToRepresentativeDiagram[btab2],st1=StabilityIndex[btab1],st2=StabilityIndex[btab2],n=Length[Flatten@@btab1],rulesymfactor},
rulesymfactor=Map[#->StabilityIndex[#]*HoldPattern[#]&,BrauerBracelets[n]];
If[st1>=st2,
Collect[ReleaseHold[1/st2*(ToBracelets[Collect[BrauerProduct[{\[Delta]},ConjugacyClassSum[btab1],rep2],{_BrauerList},Factor]])/.rulesymfactor],{_Bracelets},Factor],
Collect[ReleaseHold[1/st1*(ToBracelets[Collect[BrauerProduct[{\[Delta]},rep1,ConjugacyClassSum[btab2]],{_BrauerList},Factor]])/.rulesymfactor],{_Bracelets},Factor]]
]


(* ::Input::Initialization:: *)
ConjugacyClassProductCompare[{\[Delta]_},btab1_Bracelets?(!IdClassQ[#]&),btab2_Bracelets?(!IdClassQ[#]&)]:=Module[{rep1=ToRepresentativeDiagram[btab1],rep2=ToRepresentativeDiagram[btab2],st1=StabilityIndex[btab1],st2=StabilityIndex[btab2],n=Length[Flatten@@btab1],rulesymfactor},
rulesymfactor=Map[#->StabilityIndex[#]*HoldPattern[#]&,BrauerBracelets[n]];
If[st1>=st2,
Collect[ReleaseHold[1/st2*(ToBracelets[Collect[BrauerProduct[{\[Delta]},ConjugacyClassSum[btab1],rep2],{_BrauerList},Factor]])/.rulesymfactor],{_Bracelets},Factor],
Collect[ReleaseHold[1/st1*(ToBracelets[Collect[BrauerProduct[{\[Delta]},rep1,ConjugacyClassSum[btab2]],{_BrauerList},Factor]])/.rulesymfactor],{_Bracelets},Factor]]
]
ConjugacyClassProductCompare[btab1_Bracelets,btab2_Bracelets]:=ConjugacyClassProductCompare[{BrauerParameter[]},btab1,btab2];
ConjugacyClassProductCompare[btab1_Bracelets?IdClassQ,btab2_Bracelets]:=btab2;
ConjugacyClassProductCompare[btab1_Bracelets,btab2_Bracelets?IdClassQ]:=btab1;


(* ::Input::Initialization:: *)
(************** Optimization of the Product for the class AClass[n,1] and TClass[n,1](class A1 of the article see section 5 of the article or section 8 of this notebook : A1 acts as a second differential operator on the space of bracelets (1,2,3) )****)
AClass[n_,f_]:=Bracelets[Join[ConstantArray[{1,2} ,f],ConstantArray[{3},n-2*f]]];
(*AClass[1,ntraces_]:=Bracelets[{{3}}]*)
AClass[n_,0]:=IdClass[n]
AClass[0,f_]:={};
AClass[1,ntraces_]:=0;
AClassQ[f_,btab_Bracelets]:=With[{n=Length[Flatten@@btab]},AClass[n,f]===btab];
ConjugacyClassProduct[{\[Delta]_},tab1_Bracelets?(AClassQ[1,#]&),tab2_Bracelets]:=AProductNormalized[tab2,\[Delta]];
ConjugacyClassProduct[{\[Delta]_},tab1_Bracelets,tab2_Bracelets?(AClassQ[1,#]&)]:=AProductNormalized[tab1,\[Delta]];
(*********************** Product with the class TClass[n,1] **********)
ConjugacyClassProduct[{\[Delta]_},tab1_Bracelets?(TClassQ[1,#]&),tab2_Bracelets]:=TProductNormalized[tab2];
ConjugacyClassProduct[{\[Delta]_},tab1_Bracelets,tab2_Bracelets?(TClassQ[1,#]&)]:=TProductNormalized[tab1];
ConjugacyClassProduct[{\[Delta]_},tab1_Bracelets?(TClassQ[1,#]&),tab2_Bracelets,options___?OptionQ]:=TProductNormalized[tab2];
ConjugacyClassProduct[{\[Delta]_},tab1_Bracelets,tab2_Bracelets?(TClassQ[1,#]&),options___?OptionQ]:=TProductNormalized[tab1];
(*********************** ClassSum Head *******************************)



(* ::Input::Initialization:: *)
TClassQ[nt_,\[Mu]_List]:=Max[\[Mu]]===2&&Count[\[Mu],2]==nt;


(* ::Input::Initialization:: *)
ConjugacyClassProduct[{\[Delta]_},ClassSum[\[Mu]1_List?(!TClassQ[1,#]&)],ClassSum[\[Mu]2_List?(!TClassQ[1,#]&)]]:=With[{n=Tr[\[Mu]1]},Map[ClassSum[#]&,IntegerPartitions[n]] . ConnectionCoefficientsClassProductSym[\[Mu]1,\[Mu]2,n]]
BraceletsToClassSumSn0[bracelets_Bracelets]:=ClassSum[Length/@Sequence@@bracelets]
BraceletsToClassSumSn[exp_]:=exp/.x_Bracelets:>BraceletsToClassSumSn0[x]
ConjugacyClassProduct[{\[Delta]_},ClassSum[\[Mu]1_List?(TClassQ[1,#]&)],ClassSum[\[Mu]2_List]]:=BraceletsToClassSumSn[TProductNormalized[PartitionToBracelets[\[Mu]2]]];
ConjugacyClassProduct[{\[Delta]_},ClassSum[\[Mu]1_List],ClassSum[\[Mu]2_List?(TClassQ[1,#]&)]]:=BraceletsToClassSumSn[TProductNormalized[PartitionToBracelets[\[Mu]1]]];


(* ::Input::Initialization:: *)
(************** Passing from IntegerPartitions/Bracelets to ClassSum *************)
IntegerPartitionQ[\[Mu]_]:=ListQ[\[Mu]]&&AllTrue[\[Mu],IntegerQ]&&AllTrue[Differences[\[Mu]],#<=0&]
ToClassSum0[bracelets_Bracelets]:=ClassSum[bracelets]
ToClassSum0[\[Mu]_?IntegerPartitionQ]:=ClassSum[\[Mu]]
ToClassSum[exp_]:=exp/.x_Bracelets|x_List?IntegerPartitionQ:>ToClassSum0[x]


(* ::Input::Initialization:: *)
(*********** ConjugacyClassProduct between ClassSum : this is the correct way of doing things ***********)
ConjugacyClassProduct[{\[Delta]_},ClassSum[bra1_Bracelets],ClassSum[bra2_Bracelets]]:=ToClassSum[ConjugacyClassProduct[{\[Delta]},bra1,bra2 ]];


(* ::Input::Initialization:: *)
FactorSpaceRule[f_]:={bracelets_Bracelets/;(Narcs[bracelets]=!=f):>0,blist_Brauerlist/;(Narcs[blist]=!=f):>0}


(* ::Input::Initialization:: *)
Options[ConjugacyClassRelations]:={SymmetricGroup->True,FactorSpace->False}
ConjugacyClassRelations[bracelets_Bracelets,{f1_,f2_},\[Delta]_Symbol|\[Delta]_Integer|\[Delta]_Plus|\[Delta]_Times,options:OptionsPattern[]]:=Module[{n=Length[Flatten@@bracelets],narcs=Narcs[bracelets],allbracelets=BrauerBracelets[Length[Flatten@@bracelets],f1,f2],fspaceQ,idealQ,narcsmax,symQ},
{fspaceQ}=OptionValue[{ConjugacyClassRelations},{options},{FactorSpace}];
If[fspaceQ,Map[HoldForm[ConjugacyClassProduct[{\[Delta]},bracelets,#]]==(ConjugacyClassProduct[{\[Delta]},bracelets,#])&,allbracelets]/.FactorSpaceRule[Narcs[bracelets]],
Map[HoldForm[ConjugacyClassProduct[{\[Delta]},bracelets,#]]==(ConjugacyClassProduct[{\[Delta]},bracelets,#])&,allbracelets]
]
]

ConjugacyClassRelations[bracelets_Bracelets,{f_},\[Delta]_Symbol|\[Delta]_Integer|\[Delta]_Plus|\[Delta]_Times,options:OptionsPattern[]]:=Module[{n=Length[Flatten@@bracelets],narcs=Narcs[bracelets],allbracelets=BrauerBracelets[Length[Flatten@@bracelets],f],fspaceQ,idealQ,narcsmax,symQ},
{fspaceQ}=OptionValue[{ConjugacyClassRelations},{options},{FactorSpace}];
If[fspaceQ,Map[HoldForm[ConjugacyClassProduct[{\[Delta]},bracelets,#]]==(ConjugacyClassProduct[{\[Delta]},bracelets,#])&,allbracelets]/.FactorSpaceRule[Narcs[bracelets]],
Map[HoldForm[ConjugacyClassProduct[{\[Delta]},bracelets,#]]==(ConjugacyClassProduct[{\[Delta]},bracelets,#])&,allbracelets]
]
]
ConjugacyClassRelations[bracelets_Bracelets,\[Delta]_Symbol|\[Delta]_Integer|\[Delta]_Plus|\[Delta]_Times,options:OptionsPattern[]]:=Module[{n=Length[Flatten@@bracelets],narcs=Narcs[bracelets],allbracelets,fspaceQ,symQ},
{fspaceQ,symQ}=OptionValue[{ConjugacyClassRelations},{options},{FactorSpace,SymmetricGroup}];
allbracelets=BrauerBracelets[n,SymmetricGroup->symQ];
If[fspaceQ,Map[HoldForm[ConjugacyClassProduct[{\[Delta]},bracelets,#]]==(ConjugacyClassProduct[{\[Delta]},bracelets,#])&,allbracelets]/.FactorSpaceRule[Narcs[bracelets]],
Map[HoldForm[ConjugacyClassProduct[{\[Delta]},bracelets,#]]==(ConjugacyClassProduct[{\[Delta]},bracelets,#])&,allbracelets]
]
]
ConjugacyClassRelations[bracelets_Bracelets,{f1_,f2_},options:OptionsPattern[]]:=ConjugacyClassRelations[bracelets,{f1,f2},BrauerParameter[],options]
ConjugacyClassRelations[bracelets_Bracelets,{f_},options:OptionsPattern[]]:=ConjugacyClassRelations[bracelets,{f},BrauerParameter[],options]
ConjugacyClassRelations[bracelets_Bracelets,options:OptionsPattern[]]:=ConjugacyClassRelations[bracelets,BrauerParameter[],options]


(* ::Input::Initialization:: *)
Options[StructureConstant]:={FactorSpace->False,IdealSpace->False,SymmetricGroup->False}
StructureConstant[btab_Bracelets,\[Delta]_Symbol|\[Delta]_Integer,options:OptionsPattern[]]:=Module[{n=Length[Flatten@@btab],f=Narcs[btab],fmax,fspaceQ,idealQ,symQ},
{fspaceQ,idealQ,symQ}=OptionValue[{StructureConstant},{options},{FactorSpace,IdealSpace,SymmetricGroup}];
fmax=IntegerPart[n/2];
If[idealQ,
Transpose[Normal@CoefficientArrays[ConjugacyClassRelations[btab,{f,fmax},\[Delta],FactorSpace->fspaceQ][[All,2]],BrauerBracelets[n,f,fmax]][[2]]],
Transpose[Normal@CoefficientArrays[ConjugacyClassRelations[btab,\[Delta],FactorSpace->fspaceQ,SymmetricGroup->symQ][[All,2]],BrauerBracelets[n,SymmetricGroup->symQ]][[2]]]
]
]
StructureConstant[btab_Bracelets,options:OptionsPattern[]]:=StructureConstant[btab,BrauerParameter[],options]


(* ::Input::Initialization:: *)
ExtractStructureConstantIdeal[exp_]:=Module[{n=Length[Flatten@@(exp[[1,1,1]])],f=Narcs[exp[[1,1,1]]],fmax},
fmax=IntegerPart[n/2];
Transpose[Normal@CoefficientArrays[exp[[All,2]],BrauerBracelets[n,f,fmax]][[2]]]
]
ExtractStructureConstantFactor[exp_]:=Module[{n=Length[Flatten@@(exp[[1,1,1]])],f=Narcs[exp[[1,1,1]]]},
Transpose[Normal@CoefficientArrays[exp[[All,2]],BrauerBracelets[n,f]][[2]]]
]


(* ::Input::Initialization:: *)
RuleNonCommutativeMultiply:={1**1:>1,(na_*a_Bracelets)**(nb_*b_Bracelets):>na*nb*a**b,1**a_:>a,a_**1:>a,a_Times**b_Times:>NonCommutativeMultiply[a//Expand,b//Expand],a_**exp_Plus:>Plus@@Map[a**#&,List@@exp],a_Bracelets**(na_*b_Bracelets):>na*a**b,a_Bracelets**b_Bracelets:>a/;AllTrue[Flatten[List@@b,1],#==={3}&]}


(* ::Input::Initialization:: *)
SplitCycleIntoLetter[btab_]:=Bracelets[{#}]&/@Partition[Flatten@@btab,1]
JoinLetters[btabs___]:=Bracelets[{Flatten[First@@@List[btabs]]}]
JoinLetters[btabs1___,0,btabs2___]:=0;


(* ::Input::Initialization:: *)
DerivativeLetter[btab_,0]:=btab;
DerivativeLetter[Bracelets[{{3}}],1]:=Bracelets[{{6}}];
DerivativeLetter[Bracelets[{{3}}],2]:=0;
DerivativeLetter[Bracelets[{{1}}],1]:=0;
DerivativeLetter[Bracelets[{{1}}],2]:=0;
DerivativeLetter[Bracelets[{{2}}],1]:=Bracelets[{{4}}];
DerivativeLetter[Bracelets[{{2}}],2]:=Bracelets[{{5}}];


(* ::Input::Initialization:: *)
support3Necklace[nvar_,nder_]:=myDeleteDuplicateNecklaces[Permutations@Join[ConstantArray[1,nder],ConstantArray[0,nvar-nder]]];


(* ::Input::Initialization:: *)
LengthCycle[btab_]:=Length[btab[[1,1]]];


(* ::Input::Initialization:: *)
(************** Leibniz rule *************)
DerivativeCycle[btab_?SymmetricGroupQ,n_]:=Block[{support,product},
With[{f=Length/@DeleteDuplicates/@equivalentForms/@#&,list=SplitCycleIntoLetter[btab],nvar=LengthCycle[btab]},
support=support3Necklace[nvar,n];
product=JoinLetters@@@Flatten[Outer[MapThread[DerivativeLetter[#1,#2]&,{#1,#2}]&,{list},support,1],1];
Plus@@Thread[Times[Multinomial[Sequence@@#]&/@support,f@support,product]]
]
]


(* ::Input::Initialization:: *)
DerivativeCycle[btab_?SymmetricGroupQ,n_]:=0/;n>LengthCycle[btab];
DerivativeCycle[btab_?SymmetricGroupQ,n_]:=n!*(btab/. 3->6)/;n==LengthCycle[btab];
DerivativeCycle[btab_?SymmetricGroupQ,n_]:=LengthCycle[btab]!*Bracelets[{ReplacePart[Flatten@@btab,Partition[Range[n],1]->6]}]/;n==LengthCycle[btab]-1;


(* ::Input::Initialization:: *)
myIntegerPartitions[m_,n_]:=IntegerPartitions[n,{m},Range[0,n]];
myIntegerPartitions[m_,n_,nmax_]:=IntegerPartitions[n,{m},Range[0,nmax]];


(* ::Input::Initialization:: *)
MaximalTraceCycleQ[btab_]:=!MemberQ[Flatten[btab[[1]]],3];
support2Necklace[nvar_,nder_]:=myDeleteDuplicateNecklaces[Flatten[Permutations/@myIntegerPartitions[nvar,nder,2],1]];


(* ::Input::Initialization:: *)
riffle1[list_ ,n_]:=Riffle[list,1,{1,-n,n}];
riffleTab1[btab_,n_]:=Bracelets[{riffle1[btab[[1,1]],2]}];
riffleTab1[btab_Bracelets,n_]:=Bracelets[{riffle1[btab[[1,1]],2]}];
riffleTab1[btabs_Plus,n_]:=Plus@@Map[riffleTab1[#,n]&,List@@btabs];
riffleTab1[Times[a_,btab_Bracelets],n_]:=a*riffleTab1[btab,n];
riffleTab1[Times[a_,btabs_Plus],n_]:=a*riffleTab1[btabs,n];
riffleTab1[0,n_]:=0;


(* ::Input::Initialization:: *)
DerivativeMaximalTraceCycle[btab_,n_]:=Module[{support,product,nvar=LengthCycle[btab]/2},
With[{f=Length/@DeleteDuplicates/@equivalentForms/@#&,list=DeleteCases[SplitCycleIntoLetter[btab],Bracelets[{{1}}]]},
support=support2Necklace[nvar,n];
product=JoinLetters@@@Flatten[Outer[MapThread[DerivativeLetter[#1,#2]&,{#1,#2}]&,{list},support,1],1];
riffleTab1[Plus@@Thread[Times[Multinomial[Sequence@@#]&/@support,f@support,product]],2]
]
]


(* ::Input::Initialization:: *)
DerivativeCycle[btab_?(!PrimaryCycleQ[#]&),n_]:=DerivativeMaximalTraceCycle[btab,n]/;MaximalTraceCycleQ[btab]


(* ::Input::Initialization:: *)
PrimaryCycleQ[btab_]:=Count[btab[[1,1]],1]==1;


(* ::Input::Initialization:: *)
DerivativePrimaryCycleList[list_,{3,n3_}]:=Block[{enuples,pos=Position[list,3]},
enuples=Subsets[pos,{n3}];
ReplacePart[list,#->6]&/@enuples
]
DerivativePrimaryCycleList[list_,{2,0}]:={list};
DerivativePrimaryCycleList[list_,{2,1}]:={list/. 2->4};
DerivativePrimaryCycleList[list_,{2,2}]:={list/. 2->5};
DerivativePrimaryCycleList[list_,{2,n2_?(#>2&)}]:=0;


(* ::Input::Initialization:: *)
DerivativePrimaryCycle[btab_,{3,n3_}]:=n3!*Plus@@Map[Bracelets[{#}]&,DerivativePrimaryCycleList[btab[[1,1]],{3,n3}]];
DerivativePrimaryCycle[btab_,{3,n3_}]:=0/;n3>LengthCycle[btab]-2
DerivativePrimaryCycle[btab_,{2,n2_}]:=Bracelets[DerivativePrimaryCycleList[btab[[1,1]],{2,n2}]];
DerivativePrimaryCycle[btab_,{2,n2_},{3,n3_}]:=Binomial[n2+n3,n2]*DerivativePrimaryCycle[DerivativePrimaryCycle[btab,{2,n2}],{3,n3}];
DerivativePrimaryCycle[btab_,{3,n3_},{2,n2_}]:=DerivativePrimaryCycle[btab,{2,n2},{3,n3}];


(* ::Input::Initialization:: *)
listder[n_]:=Table[{n-i,i},{i,0,2}]
DerivativePrimaryCycle[btab_,n_?(#>1&)]:=Plus@@Map[DerivativePrimaryCycle[btab,{3,#[[1]]},{2,#[[2]]}]&,listder[n]]
DerivativePrimaryCycle[btab_,n_?(#>1&)]:=0/;n>LengthCycle[btab]
DerivativePrimaryCycle[btab_,n_?(#==2&)]:=Plus@@Map[DerivativePrimaryCycle[btab,{3,#[[1]]},{2,#[[2]]}]&,{{2,0},{1,1},{0,2}}]
DerivativePrimaryCycle[btab_,n_?(#==1&)]:=Plus@@Map[DerivativePrimaryCycle[btab,{3,#[[1]]},{2,#[[2]]}]&,{{1,0},{0,1}}]
DerivativePrimaryCycle[btab_,0]:=btab;


(* ::Input::Initialization:: *)
DerivativeCycle[btab_?PrimaryCycleQ,n_]:=ToCanonicalCycle[DerivativePrimaryCycle[btab,n]];


(* ::Input::Initialization:: *)
BreakToPrimaryCyclesList[list_]:=Flatten[Partition[SplitBy[list,#==1&],2],{{1},{2,3}}]
BreakToPrimaryCycles[btab_]:=Bracelets[{#}]&/@BreakToPrimaryCyclesList[btab[[1,1]]]


(* ::Input::Initialization:: *)
JoinPrimaryCycles[btab1_Bracelets,btab2_Bracelets]:=Bracelets[Join[Sequence@@btab1,Sequence@@btab2,2]];
JoinPrimaryCycles[bsum_Plus,btab_]:=Map[JoinPrimaryCycles[#,btab]&,bsum];
JoinPrimaryCycles[btab_,bsum_Plus]:=Map[JoinPrimaryCycles[btab,#]&,bsum];
JoinPrimaryCycles[Times[n_?NumericQ,btab1_],btab2_]:=n*JoinPrimaryCycles[btab1,btab2];
JoinPrimaryCycles[btab1_,Times[n_?NumericQ,btab2_]]:=n*JoinPrimaryCycles[btab1,btab2];

(******** associativity **********)
JoinPrimaryCycles[btab1_,btab2_,btabs__]:=JoinPrimaryCycles[btab1,JoinPrimaryCycles[btab2,btabs]];


(* ::Input::Initialization:: *)
supportPrimaryCycles[nvar_,nder_,lcycles_]:=Select[Flatten[Permutations/@myIntegerPartitions[nvar,nder,Max[lcycles]],1],!MemberQ[Thread[LessEqual[#,lcycles]],False]&];


(* ::Input::Initialization:: *)
DerivativeCycle[btab_?(!PrimaryCycleQ[#]&),n_]:=Module[{support,product,list=BreakToPrimaryCycles[btab]},
With[{nvar=Length[list],lcycles=LengthCycle/@list},
support=supportPrimaryCycles[nvar,n,lcycles];
product=JoinPrimaryCycles@@@Flatten[Outer[MapThread[DerivativePrimaryCycle[#1,#2]&,{#1,#2}]&,{list},support,1],1];
Plus@@Thread[Times[Multinomial[Sequence@@#]&/@support,product]]
]
]


(* ::Input::Initialization:: *)
NCycles[btab_]:=Length@@btab;
CycleTabQ[btab_]:=NCycles[btab]==1;


(* ::Input::Initialization:: *)
DerivativeBracelets[btab_?CycleTabQ,n_]:=DerivativeCycle[btab,n];


(* ::Input::Initialization:: *)
SplitBracelet[btab_]:=Map[Bracelets[{#}]&,btab[[1]]];


(* ::Input::Initialization:: *)
MergeBracelet[btab1_Bracelets,btab2_Bracelets]:=Join[btab1,btab2,2];
MergeBracelet[bsum_Plus,btab_]:=Map[MergeBracelet[#,btab]&,bsum];
MergeBracelet[btab_,bsum_Plus]:=Map[MergeBracelet[btab,#]&,bsum];
MergeBracelet[Times[n_?NumericQ,btab1_],btab2_]:=n*MergeBracelet[btab1,btab2];
MergeBracelet[btab1_,Times[n_?NumericQ,btab2_]]:=n*MergeBracelet[btab1,btab2];
(************ associativity ****************)
(******** associativity **********)
MergeBracelet[d1_,d2_,d3__]:=MergeBracelet[d1,MergeBracelet[d2,d3]];


(* ::Input::Initialization:: *)
Derivative[n_][btab_BrauerTab][x]:=0/;n>LengthCycle[btab]


(* ::Input::Initialization:: *)
MergeBraceletSame[list_]:=Bracelets[First@@@list];
RuleDerivative={Derivative[n_][btab_][x]:>DerivativeCycle[btab,n],btab_[x]:>btab}
RulePowerTab={Power[btab_Bracelets,n_]:>MergeBraceletSame[ConstantArray[btab,n]],Power[bsum_Plus,n_]:>MergeBracelet[Sequence@@ConstantArray[bsum,n]]}
RuleMergeBracelet={Times[btab1_?(!SameQ[Head[#],Integer]&),btab2_?(!SameQ[Head[#],Integer]&)]:>MergeBracelet[btab1,btab2]}


(* ::Input::Initialization:: *)
DerivativeBracelets[btab_?(!CycleTabQ[#]&),n_Integer]:=SortTableau0[D[Times[Sequence@@Map[#[x]&,SplitBracelet[btab]]],{x,n}]/.RuleDerivative/.RulePowerTab//.RuleMergeBracelet];


(* ::Input::Initialization:: *)
SortCycles2[list_]:=SortBy[list,-Length[#]||(-Total[Evaluate[#+2]])&]
SortTableau0[btab_Bracelets]:=Bracelets[SortCycles2@@ btab];
SortTableau0[Times[n_,btab_Bracelets]]:=n*SortTableau0[ btab];
SortTableau0[Times[n_,btabPlus_Plus]]:=n*SortTableau0[btabPlus];
SortTableau0[btabsum_Plus]:=SortTableau0/@btabsum;
SortTableau0[0]:=0;


(* ::Input::Initialization:: *)
AClassContractionCycledd2Rules[\[Delta]_]:={Bracelets[{a___,{u___,5,v___},b___}]:>\[Delta]*ToCanonicalBracelets[Bracelets[{a,{u,2,v},b}]]};
AClassContractionCycled2d2Rules={Bracelets[{a___,{u1___,4,v___,4,u2___},b___}]:>ToCanonicalBracelets[Bracelets[{a,{u1,2,Sequence@@Reverse[List[v]],2,u2},b}]]+ToCanonicalBracelets[Bracelets[{a,{u2,u1,2},{v,2},b}]]};
AClassContractionCycled2d3Rules={Bracelets[{a___,{v2___,6,u___,4,v1___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{3,Sequence@@Reverse[List[v1,v2]],2,u},b}]]+1/2*ToCanonicalBracelets[Bracelets[{a,{v1,v2,3},{u,2},b}]]/;Count[List[v1,v2],1]==Count[List[v1,v2],2],Bracelets[{a___,{v2___,6,u___,4,v1___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{3,v1,v2,2,Sequence@@Reverse[List[u]]},b}]]+1/2*ToCanonicalBracelets[Bracelets[{a,{v1,v2,2},{u,3},b}]]/;Count[List[v1,v2],1]!=Count[List[v1,v2],2],
Bracelets[{a___,{v2___,4,u___,6,v1___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{3,u,2,Sequence@@Reverse[List[v1,v2]]},b}]]+1/2*ToCanonicalBracelets[Bracelets[{a,{u,2},{v1,v2,3},b}]]/;Count[List[u],1]!=Count[List[u],2],
Bracelets[{a___,{v2___,4,u___,6,v1___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{3,Sequence@@Reverse[List@u],2,v1,v2},b}]]+1/2*ToCanonicalBracelets[Bracelets[{a,{u,3},{v1,v2,2},b}]]/;Count[List[u],1]==Count[List[u],2]};
AClassContractionCycled3d3Rules={Bracelets[{a___,{u1___,6,v___,6,u2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{u1,1,Sequence@@Reverse[List[v]],2,u2},b}]]/;(Count[List[u1],1]==Count[List[u1],2]&&Count[List[v],1]==Count[List[v],2]),Bracelets[{a___,{u1___,6,v___,6,u2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{u1,2,Sequence@@Reverse[List[v]],1,u2},b}]]/;(Count[List[u1],1]!=Count[List[u1],2]&&Count[List[v],1]==Count[List[v],2]),Bracelets[{a___,{u1___,6,v___,6,u2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{2,v},{1,u2,u1},b}]]/;(Count[List[u1],1]==Count[List[u1],2]&&Count[List[v],1]!=Count[List[v],2]),
Bracelets[{a___,{u1___,6,v___,6,u2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{2,u2,u1},{1,v},b}]]/;(Count[List[u1],1]=!=Count[List[u1],2]&&Count[List[v],1]!=Count[List[v],2])};
AClassContractionCycled3d3RulesFactor={Bracelets[{a___,{u1___,6,v___,6,u2___},b___}]:>0};

AClassContractionCycleRules[\[Delta]_]:=Join[AClassContractionCycledd2Rules[\[Delta]],AClassContractionCycled2d2Rules,AClassContractionCycled2d3Rules,AClassContractionCycled3d3Rules];
AClassContractionCycleRulesFactor[\[Delta]_]:=Join[AClassContractionCycledd2Rules[\[Delta]],AClassContractionCycled2d2Rules,AClassContractionCycled2d3Rules,AClassContractionCycled3d3RulesFactor];


(* ::Input::Initialization:: *)
AClassContraction2Cyclesd2d2Rules={Bracelets[{a___,{u1__,4,u2___},c___,{v1__,4,v2___},b___}]:>ToCanonicalBracelets[Bracelets[{a,{2,u2,u1,2,v2,v1},c,b}]]+ToCanonicalBracelets[Bracelets[{a,{2,u2,u1,2,Sequence@@Reverse[List[v2,v1]]},c,b}]]};
AClassContraction2Cyclesd2d3Rules={Bracelets[{a___,{u1___,6,u2___},c___,{v1__,4,v2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{2,u2,u1,3,v2,v1},c,b}]]+1/2*ToCanonicalBracelets[Bracelets[{a,{2,u2,u1,3,Sequence@@Reverse[List[v2,v1]]},c,b}]]/;Count[List[u1],1]==Count[List[u1],2],Bracelets[{a___,{u1___,6,u2___},c___,{v1__,4,v2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{2,Sequence@@Reverse[List[u2,u1]],3,v2,v1},c,b}]]+1/2*ToCanonicalBracelets[Bracelets[{a,{2,Sequence@@Reverse[List[u2,u1]],3,Sequence@@Reverse[List[v2,v1]]},c,b}]]/;Count[List[u1],1]!=Count[List[u1],2],Bracelets[{a___,{v1__,4,v2___},c___,{u1___,6,u2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{2,u2,u1,3,v2,v1},c,b}]]+1/2*ToCanonicalBracelets[Bracelets[{a,{2,u2,u1,3,Sequence@@Reverse[List[v2,v1]]},c,b}]]/;Count[List[u1],1]==Count[List[u1],2],Bracelets[{a___,{v1__,4,v2___},c___,{u1___,6,u2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{2,Sequence@@Reverse[List[u2,u1]],3,v2,v1},c,b}]]+1/2*ToCanonicalBracelets[Bracelets[{a,{2,Sequence@@Reverse[List[u2,u1]],3,Sequence@@Reverse[List[v2,v1]]},c,b}]]/;Count[List[u1],1]!=Count[List[u1],2]
};
AClassContraction2Cyclesd3d3Rules={Bracelets[{a___,{u1___,6,u2___},c___,{v1___,6,v2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{1,u2,u1,2,v2,v1},c,b}]]/;Count[List[u1],1]!=Count[List[u1],2]&&Count[List[v1],1]==Count[List[v1],2],
Bracelets[{a___,{u1___,6,u2___},c___,{v1___,6,v2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{1,u2,u1,2,Sequence@@Reverse[List[v2,v1]]},c,b}]]/;Count[List[u1],1]!=Count[List[u1],2]&&Count[List[v1],1]!=Count[List[v1],2],Bracelets[{a___,{u1___,6,u2___},c___,{v1___,6,v2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{1,Sequence@@Reverse[List[u2,u1]],2,v2,v1},c,b}]]/;Count[List[u1],1]==Count[List[u1],2]&&Count[List[v1],1]==Count[List[v1],2],
Bracelets[{a___,{u1___,6,u2___},c___,{v1___,6,v2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{1,Sequence@@Reverse[List[u2,u1]],2,Sequence@@Reverse[List[v2,v1]]},c,b}]]/;Count[List[u1],1]==Count[List[u1],2]&&Count[List[v1],1]!=Count[List[v1],2]};
AClassContraction2Cyclesd3d3RulesFactor={Bracelets[{a___,{u1___,6,u2___},c___,{v1___,6,v2___},b___}]:>0};

AClassContraction2CyclesRules=Join[AClassContraction2Cyclesd2d2Rules,AClassContraction2Cyclesd2d3Rules,AClassContraction2Cyclesd3d3Rules];
AClassContraction2CyclesRulesFactor=Join[AClassContraction2Cyclesd2d2Rules,AClassContraction2Cyclesd2d3Rules,AClassContraction2Cyclesd3d3RulesFactor];


(* ::Input::Initialization:: *)
TClassContractionCycledd2Rules={Bracelets[{a___,{u__,5,v___},b___}]:>ToCanonicalBracelets[Bracelets[{a,{u,2,v},b}]]};
TClassContractionCycled2d2Rules={Bracelets[{a___,{u1__,4,v__,4,u2___},b___}]:>ToCanonicalBracelets[Bracelets[{a,{u1,2,Sequence@@Reverse[List[v]],2,u2},b}]]+ToCanonicalBracelets[Bracelets[{a,{u2,u1,2},{v,2},b}]]};
TClassContractionCycled2d3Rules={
Bracelets[{a___,{v2___,6,u___,4,v1___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{3,u,2,Sequence@@Reverse[List[v1,v2]]},b}]]+1/2*ToCanonicalBracelets[Bracelets[{a,{3,u},{2,v1,v2},b}]]/;Count[List[u],1]==Count[List[u],2],Bracelets[{a___,{v2___,6,u___,4,v1___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{3,Sequence@@Reverse[List[v1,v2]],2,u},b}]]+1/2*ToCanonicalBracelets[Bracelets[{a,{v1,v2,3},{u,2},b}]]/;Count[List[u],1]!=Count[List[u],2],
Bracelets[{a___,{u1___,4,v___,6,u2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{3,u2,u1,2,Sequence@@Reverse[List@v]},b}]]+1/2*ToCanonicalBracelets[Bracelets[{a,{3,u2,u1},{2,v},b}]]/;Count[List[v],1]!=Count[List[v],2],
Bracelets[{a___,{u1__,4,v___,6,u2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{3,Sequence@@Reverse[List[v]],2,u2,u1},b}]]+1/2*ToCanonicalBracelets[Bracelets[{a,{3,v},{2,Sequence@@Reverse[List[u2,u1]]},b}]]/;Count[List[v],1]==Count[List[v],2]
};
TClassContractionCycled3d3Rules={Bracelets[{a___,{u1___,6,v___,6,u2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{3,v},{3,u2,u1},b}]]/;(Count[List[v],1]==Count[List[v],2]),Bracelets[{a___,{u1___,6,v___,6,u2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{3,v,3,Sequence@@Reverse[List[u2,u1]]},b}]]/;Count[List[v],1]!=Count[List[v],2]};
TClassContractionCycleRules=Join[TClassContractionCycledd2Rules,TClassContractionCycled2d2Rules,TClassContractionCycled2d3Rules,TClassContractionCycled3d3Rules];


(* ::Input::Initialization:: *)
TClassContraction2Cyclesd2d2Rules={Bracelets[{a___,{u1__,4,u2___},c___,{v1__,4,v2___},b___}]:>ToCanonicalBracelets[Bracelets[{a,{2,u2,u1,2,v2,v1},c,b}]]+ToCanonicalBracelets[Bracelets[{a,{2,u2,u1,2,Sequence@@Reverse[List[v2,v1]]},c,b}]]};
TClassContraction2Cyclesd2d3Rules={Bracelets[{a___,{u1___,6,u2___},c___,{v1__,4,v2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{2,u2,u1,3,v2,v1},c,b}]]+1/2*ToCanonicalBracelets[Bracelets[{a,{2,u2,u1,3,Sequence@@Reverse[List[v2,v1]]},c,b}]]/;Count[List[u1],1]==Count[List[u1],2],Bracelets[{a___,{u1___,6,u2___},c___,{v1__,4,v2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{2,Sequence@@Reverse[List[u2,u1]],3,v2,v1},c,b}]]+1/2*ToCanonicalBracelets[Bracelets[{a,{2,Sequence@@Reverse[List[u2,u1]],3,Sequence@@Reverse[List[v2,v1]]},c,b}]]/;Count[List[u1],1]!=Count[List[u1],2],Bracelets[{a___,{v1__,4,v2___},c___,{u1___,6,u2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{2,u2,u1,3,v2,v1},c,b}]]+1/2*ToCanonicalBracelets[Bracelets[{a,{2,u2,u1,3,Sequence@@Reverse[List[v2,v1]]},c,b}]]/;Count[List[u1],1]==Count[List[u1],2],Bracelets[{a___,{v1__,4,v2___},c___,{u1___,6,u2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{2,Sequence@@Reverse[List[u2,u1]],3,v2,v1},c,b}]]+1/2*ToCanonicalBracelets[Bracelets[{a,{2,Sequence@@Reverse[List[u2,u1]],3,Sequence@@Reverse[List[v2,v1]]},c,b}]]/;Count[List[u1],1]!=Count[List[u1],2]
};
TClassContraction2Cyclesd3d3Rules={Bracelets[{a___,{u1___,6,u2___},c___,{v1___,6,v2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{3,u2,u1,3,v2,v1},c,b}]]/;Count[List[u1],1]==Count[List[u1],2]&&Count[List[v1],1]==Count[List[v1],2],Bracelets[{a___,{u1___,6,u2___},c___,{v1___,6,v2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{3,u2,u1,3,Sequence@@Reverse[List[v2,v1]]},c,b}]]/;Count[List[u1],1]!=Count[List[u1],2]&&Count[List[v1],1]!=Count[List[v1],2],Bracelets[{a___,{u1___,6,u2___},c___,{v1___,6,v2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{3,Sequence@@Reverse[List[u2,u1]],3,v2,v1},c,b}]]/;Count[List[u1],1]!=Count[List[u1],2]&&Count[List[v1],1]==Count[List[v1],2],
Bracelets[{a___,{u1___,6,u2___},c___,{v1___,6,v2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{3,Sequence@@Reverse[List[u2,u1]],3,Sequence@@Reverse[List[v2,v1]]},c,b}]]/;Count[List[u1],1]==Count[List[u1],2]&&Count[List[v1],1]!=Count[List[v1],2]};
TClassContraction2CyclesRules=Join[TClassContraction2Cyclesd2d2Rules,TClassContraction2Cyclesd2d3Rules,TClassContraction2Cyclesd3d3Rules];


(* ::Input::Initialization:: *)
XClassContractionCycledd2Rules[\[Delta]_]:={Bracelets[{a___,{u___,5,v___},b___}]:>(1-\[Delta])*ToCanonicalBracelets[Bracelets[{a,{u,2,v},b}]]};
XClassContractionCycled2d2Rules={Bracelets[{a___,{u1__,4,v__,4,u2___},b___}]:>0};
XClassContractionCycled2d3Rules={Bracelets[{a___,{u1__,4,v___,6,u2___},b___}]:>0,Bracelets[{a___,{u1___,6,v___,4,u2___},b___}]:>0};
XClassContractionCycled3d3Rules={Bracelets[{a___,{u1___,6,v___,6,u2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{3,v},{3,u2,u1},b}]]-1/2*ToCanonicalBracelets[Bracelets[{a,{u1,1,Sequence@@Reverse[List[v]],2,u2},b}]]/;(Count[List[u1],1]==Count[List[u1],2]&&Count[List[v],1]==Count[List[v],2]),Bracelets[{a___,{u1___,6,v___,6,u2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{3,v},{3,u2,u1},b}]]-1/2*ToCanonicalBracelets[Bracelets[{a,{u1,2,Sequence@@Reverse[List[v]],1,u2},b}]]/;(Count[List[u1],1]!=Count[List[u1],2]&&Count[List[v],1]==Count[List[v],2]),Bracelets[{a___,{u1___,6,v___,6,u2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{3,v,3,Sequence@@Reverse[List[u2,u1]]},b}]]-1/2*ToCanonicalBracelets[Bracelets[{a,{2,v},{1,u2,u1},b}]]/;(Count[List[u1],1]==Count[List[u1],2]&&Count[List[v],1]!=Count[List[v],2]),
Bracelets[{a___,{u1___,6,v___,6,u2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{3,v,3,Sequence@@Reverse[List[u2,u1]]},b}]]-1/2*ToCanonicalBracelets[Bracelets[{a,{2,u2,u1},{1,v},b}]]/;(Count[List[u1],1]=!=Count[List[u1],2]&&Count[List[v],1]!=Count[List[v],2])};
XClassContractionCycleRules[\[Delta]_]:=Join[XClassContractionCycledd2Rules[\[Delta]],XClassContractionCycled2d2Rules,XClassContractionCycled2d3Rules,XClassContractionCycled3d3Rules];


(* ::Input::Initialization:: *)
XClassContraction2Cyclesd2d2Rules={Bracelets[{a___,{u1__,4,u2___},c___,{v1__,4,v2___},b___}]:>0};
XClassContraction2Cyclesd2d3Rules={Bracelets[{a___,{u1___,6,u2___},c___,{v1__,4,v2___},b___}]:>0,Bracelets[{a___,{u1__,4,u2___},c___,{v1___,6,v2___},b___}]:>0};
XClassContraction2Cyclesd3d3Rules={Bracelets[{a___,{u1___,6,u2___},c___,{v1___,6,v2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{3,Sequence@@Reverse[List[u2,u1]],3,v2,v1},c,b}]]-1/2*ToCanonicalBracelets[Bracelets[{a,{1,u2,u1,2,v2,v1},c,b}]]/;Count[List[u1],1]!=Count[List[u1],2]&&Count[List[v1],1]==Count[List[v1],2],
Bracelets[{a___,{u1___,6,u2___},c___,{v1___,6,v2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{3,u2,u1,3,Sequence@@Reverse[List[v2,v1]]},c,b}]]-1/2*ToCanonicalBracelets[Bracelets[{a,{1,u2,u1,2,Sequence@@Reverse[List[v2,v1]]},c,b}]]/;Count[List[u1],1]!=Count[List[u1],2]&&Count[List[v1],1]!=Count[List[v1],2],Bracelets[{a___,{u1___,6,u2___},c___,{v1___,6,v2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{3,u2,u1,3,v2,v1},c,b}]]-1/2*ToCanonicalBracelets[Bracelets[{a,{1,Sequence@@Reverse[List[u2,u1]],2,v2,v1},c,b}]]/;Count[List[u1],1]==Count[List[u1],2]&&Count[List[v1],1]==Count[List[v1],2],
Bracelets[{a___,{u1___,6,u2___},c___,{v1___,6,v2___},b___}]:>1/2*ToCanonicalBracelets[Bracelets[{a,{3,Sequence@@Reverse[List[u2,u1]],3,Sequence@@Reverse[List[v2,v1]]},c,b}]]-1/2*ToCanonicalBracelets[Bracelets[{a,{1,Sequence@@Reverse[List[u2,u1]],2,Sequence@@Reverse[List[v2,v1]]},c,b}]]/;Count[List[u1],1]==Count[List[u1],2]&&Count[List[v1],1]!=Count[List[v1],2]};

XClassContraction2CyclesRules=Join[XClassContraction2Cyclesd2d2Rules,XClassContraction2Cyclesd2d3Rules,XClassContraction2Cyclesd3d3Rules];


(* ::Input::Initialization:: *)
AProductNotNormalized[btab_,\[Delta]_]:=
ToCanonicalBracelets[DerivativeBracelets[btab,2]/.AClassContractionCycleRules[\[Delta]]/.AClassContraction2CyclesRules]
(****** The algorithm for the passage from Non-normalized  to Normalized class is given in the section below ****)
AProductNormalized[btab_,\[Delta]_]:=Collect[1/StabilityIndex[btab]*RenormalizeClass[AProductNotNormalized[btab,\[Delta]]],{_Bracelets},Factor];
AProductNormalized[btab_]:=AProductNormalized[btab,BrauerParameter[]];


(* ::Input::Initialization:: *)
TProductNotNormalized[btab_]:=
DerivativeBracelets[btab,2]/.TClassContractionCycleRules/.TClassContraction2CyclesRules
TProductNormalized[btab_]:=Collect[1/StabilityIndex[btab]RenormalizeClass[TProductNotNormalized[btab]],{_Bracelets},Factor];


(* ::Input::Initialization:: *)
XProductNotNormalized[btab_,\[Delta]_,options___?OptionQ]:=DerivativeBracelets[btab,2]/.XClassContractionCycleRules[\[Delta]]/.XClassContraction2CyclesRules
(****** The algorithm for the passage from Non-normalized  to Normalized class is given in the section below ****)
XProductNormalized[btab_,\[Delta]_,options___?OptionQ]:=Collect[1/StabilityIndex[btab]*RenormalizeClass[XProductNotNormalized[btab,\[Delta],options]],{_Bracelets},Factor];
XProductNormalized[btab_,options___?OptionQ]:=XProductNormalized[btab,BrauerParameter[],options];


(* ::Input::Initialization:: *)
NextDiagrams[{}]:={{1}}
NextDiagrams[\[Mu]_]:=Join[InverseLittlewoodRichardsonRule[\[Mu],{1}],LittlewoodRichardsonRule[\[Mu],{1}]]
NextPath[path:{\[Mu]___List,\[Mu]last:{___Integer}}]:=Map[{\[Mu],\[Mu]last,#}&,NextDiagrams[\[Mu]last]];
NextPath[x:{paths___?(Depth[#]==3&)}]:=Flatten[Map[NextPath[#]&,x],1];
(******* BratteliPath not optimized *****)
BratteliPathBn[n_,\[Mu]_]:=Select[BratteliDiagramBn[n],Last[#]===\[Mu]&];
(************** Bratteli diagram : main function **************)
BratteliDiagramBn0[n_]:=Nest[NextPath,{{{1}}},n-1];
Options[BratteliDiagramBn]:={Output->List,ImageSize->600,Thickness->0.001,VertexSize->0.016,AspectRatio->1}
BratteliDiagramBn[n_,options:OptionsPattern[]]:=Module[{bratteli=BratteliDiagramBn0[n],output,imagesize,thickness,vsize,aspectratio},
{output,imagesize,thickness,vsize,aspectratio}=OptionValue[{BratteliDiagramBn},{options},{Output,ImageSize,Thickness,VertexSize,AspectRatio}];
If[output===List,Return[BratteliDiagramBn0[n],Module]];
If[output===Graph,BratteliGraphBn[bratteli,n,ImageSize->imagesize,Thickness->thickness,VertexSize->vsize,AspectRatio->aspectratio]]
]


(* ::Input::Initialization:: *)
numberOfvertexBn0[n_]/;EvenQ[n]:=Plus@@(Map[PartitionsP[#]&,Range[0,n,2]]);
numberOfvertexBn0[n_]/;OddQ[n]:=Plus@@(Map[PartitionsP[#]&,Range[1,n,2]]);
numberOfvertexBn[n_]:=Plus@@Map[numberOfvertexBn0[#]&,Range[n]]+1


(* ::Input::Initialization:: *)
integerpartitionsBn0[n_]/;EvenQ[n]:=Flatten[Map[IntegerPartitions[#]&,Range[0,n,2]],1];
integerpartitionsBn0[n_]/;OddQ[n]:=Flatten[Map[IntegerPartitions[#]&,Range[1,n,2]],1];
integerpartitionsBn[n_]:=Map[integerpartitionsBn0[#]&,Range[n]]


(* ::Input::Initialization:: *)
partitionsRuleVerticesBn0[n0_]:=Thread[Rule[integerpartitionsBn0[n0],Range[numberOfvertexBn[n0-1]+1,numberOfvertexBn[n0]]]]
partitionsRulesVerticesBn[n_]:=Join[{{{}->1}},Map[partitionsRuleVerticesBn0[#]&,Range[n]]]


(* ::Input::Initialization:: *)
xcoordinatesBn0[n0_,step_]:=((Range[numberOfvertexBn0[n0]]-1)*step-((numberOfvertexBn0[n0]-1)*step/2));
HorizontaleStep[n0_,scale_]:=4*n0/(n0*scale);
xcoordinatesBn[n_,scale_]:=Join[{{0}},Map[xcoordinatesBn0[#,HorizontaleStep[#,scale]]&,Range[n]]];


(* ::Input::Initialization:: *)
VerticalStep[n0_,scale_]:=n0/(scale);
ycoordinates0[n0_,scale_]:=Plus@@Map[VerticalStep[#,scale]&,Range[n0]];
ycoordinates[n_,scale_]:=Join[{{0}},Map[{-ycoordinates0[#,scale]-ycoordinates0[1,scale]}&,Range[n]]];


(* ::Input::Initialization:: *)
mergecoordinates[list1_,list2_]:=Map[{#,list2}&,list1]
vertexcoordinatesBn[1,horizontalscale_,verticalscale_]:=Flatten/@MapThread[{#1,#2}&,{xcoordinatesBn[1,horizontalscale],ycoordinates[1,verticalscale]}]
vertexcoordinatesBn[n_,horizontalscale_,verticalscale_]:=Flatten[Inner[mergecoordinates,xcoordinatesBn[n,horizontalscale],ycoordinates[n,verticalscale],List],2]


(* ::Input::Initialization:: *)
PathToEdges[path_,rule_]:=UndirectedEdge@@@Partition[MapThread[#1/.#2&,{path,rule}],2,1]
edgesBratteliBn[bratteli_,rule_]:=Join[{UndirectedEdge[1,2]},DeleteDuplicates[Flatten[Map[PathToEdges[#,rule]&,bratteli],1]]]


(* ::Input::Initialization:: *)
verticesSizeBn[list_,scale_]:=Map[If[#[[1]]==={},#[[2]]->{"Scaled",1.8*scale},If[#[[1]]==={1},#[[2]]->{"Scaled",1.3*scale},#[[2]]->{"Scaled",Plus@@#[[1]]*scale}]]&,list]


(* ::Input::Initialization:: *)
Options[BratteliGraphBn]:={ImageSize->600,Thickness->0.001,VertexSize->0.016,AspectRatio->1}
BratteliGraphBn[bratteli_List,n_,options:OptionsPattern[]]:=Module[{coordinates,partitionsToVertex,imagesize,thickness,vertexsize,edges,aspectratio,vscale},
{imagesize,thickness,vertexsize,aspectratio}=OptionValue[{BratteliGraphBn},{options},{ImageSize,Thickness,VertexSize,AspectRatio}];
With[{nvertices=numberOfvertexBn[n],hscale=1},
vscale=aspectratio*hscale;
partitionsToVertex=partitionsRulesVerticesBn[n];
coordinates=vertexcoordinatesBn[n,vertexsize,vertexsize*vscale];
edges=edgesBratteliBn[bratteli,Rest[partitionsToVertex]];
Graph[Range[nvertices],edges,VertexCoordinates ->coordinates,EdgeStyle ->{Directive[Opacity[1], Thickness[thickness],Black]},VertexShape->Map[#[[2]]->TableauForm[#[[1]],0.2]&,Flatten[partitionsToVertex,1]],VertexStyle->Join[Map[#->Black&,Range[nvertices]]],VertexSize->Join[{1->{"Scaled",1.8*vertexsize}},verticesSizeBn[Flatten[Rest@partitionsToVertex,1],vertexsize]],ImageSize->imagesize]]]
BratteliGraphBn[bratteli_List,options:OptionsPattern[]]:=BratteliGraphBn[bratteli,Plus@@Last[bratteli[[1]]],options];


(* ::Input::Initialization:: *)
IrrepsOfBrauer[n_,f_]:=IntegerPartitions[n-2f]
IrrepsOfBrauer[n_,f1_,f2_]:=Flatten[Map[IrrepsOfBrauer[n,#]&,Range[f1,f2]],1]
IrrepsOfBrauer[n_]:=Flatten[Map[IntegerPartitions[n-2#]&,Reverse[Range[0,IntegerPart[n/2]]]],1]


(* ::Input::Initialization:: *)
DimOfIrrepBn[n_,{}]:=With[{f=n/2},(Product[Binomial[n-2 i,2]/(i+1),{i,0,f-1}])];
DimOfIrrepBn[n_,\[Mu]_List]:=With[{f=(n-Plus@@\[Mu])/2},DimOfIrrepSn[\[Mu]]*(Product[Binomial[n-2 i,2]/(i+1),{i,0,f-1}])]


(* ::Input::Initialization:: *)
Unprotect[BranchingRule];
BranchingRule::Brauer="There partition `1` is not associated with a simple module of the Brauer algebra.";


(* ::Input::Initialization:: *)
BranchingRule[\[Lambda]_List,BrauerAlgebra[n_,\[Delta]___],rest___]/;!MemberQ[IrrepsOfBrauer[n],\[Lambda]]:=Throw[Message[BranchingRule::Brauer,\[Lambda]]]


(* ::Input::Initialization:: *)
BranchingRule[{},BrauerAlgebra[n1_,\[Delta]___],BrauerAlgebra[n2_,\[Delta]___]]/;n2==n1-1:={{1}};
BranchingRule[\[Lambda]_List,BrauerAlgebra[n1_,\[Delta]___Symbol],BrauerAlgebra[n2_,\[Delta]___Symbol]]/;n2==n1-1:=With[{n\[Lambda]=Tr[\[Lambda]],l\[Lambda]=Length[\[Lambda]]},
If[n\[Lambda]===n1,
DeleteDuplicates@Map[DeleteCases[ReverseSort[\[Lambda]-#],0]&,NestList[RotateLeft[#,1]&,PadLeft[{1},l\[Lambda]],l\[Lambda]-1]],
With[{\[Lambda]p=PadLeft[\[Lambda],l\[Lambda]+1]},Join[DeleteDuplicates@Map[DeleteCases[ReverseSort[\[Lambda]-#],0]&,NestList[RotateLeft[#,1]&,PadLeft[{1},l\[Lambda]],l\[Lambda]-1]],DeleteDuplicates@Map[DeleteCases[ReverseSort[\[Lambda]p+#],0]&,NestList[RotateLeft[#,1]&,PadLeft[{1},l\[Lambda]+1],l\[Lambda]]]]]
]
]


(* ::Input::Initialization:: *)
BranchingRuleMap[list_,BrauerAlgebra[n1_,\[Delta]___Symbol],BrauerAlgebra[n2_,\[Delta]___Symbol]]:=Flatten[Map[BranchingRule[#,BrauerAlgebra[n1,\[Delta]],BrauerAlgebra[n2,\[Delta]]]&,list],1]
BranchingRule[\[Lambda]_List,BrauerAlgebra[n1_,\[Delta]___Symbol],BrauerAlgebra[n2_,\[Delta]___Symbol]]:=Module[{temp=BranchingRule[\[Lambda],BrauerAlgebra[n1,\[Delta]],BrauerAlgebra[n1-1,\[Delta]]]},
Do[temp=BranchingRuleMap[temp,BrauerAlgebra[n1-i,\[Delta]],BrauerAlgebra[n1-i-1,\[Delta]]],{i,1,n1-n2-1}];
SortBy[temp,Tr[#]&]
]
BranchingRule[\[Lambda]_List,BrauerAlgebra[n1_,\[Delta]___Symbol]]:=BranchingRule[\[Lambda],BrauerAlgebra[n1,\[Delta]],BrauerAlgebra[n1-1,\[Delta]]]


(* ::Input::Initialization:: *)
BranchingRule[\[Lambda]_List,BrauerAlgebra[n_,\[Delta]___Symbol],SymmetricGroup[n_]]:=With[{f=(n-Tr[\[Lambda]])/2},
Sort[Flatten[Map[LittlewoodRichardsonRule[#,\[Lambda]]&,EvenPartition[f]],1],Max[#1]>=Max[#2]&]
]
Protect[BranchingRule];


(* ::Input::Initialization:: *)
(********* We will need the following restriction on the partitions because we are interested in the modules of Subscript[B, n ]which appear in 
V^(\[TensorProduct]n) with dim V = N . see for example : Young's orthogonal form for Brauer's centralizer algebra M. Nazarov and 
Brauer algebras,symplectic Schur algebras and Schur-Weyl duality R. Dipper, S. Doty and J. Hu **********)

(*** When \[Delta]=\[Epsilon]N with N>0 : for the orthogonal group : we take  \[Lambda] with at most N boxes in the two first column and we take \[Mu] with at most N boxes in the first column,
for the symplectic group : we take  \[Lambda] with at most N/2 boxes in the first line and we take \[Mu] with at most N boxes in the first line,
 ***)

(***** We restrict  the simple Brauer module : also note that
here dim=\[Epsilon]N where \[Epsilon]=\[PlusMinus]1 ****)
BrauerModuleRestrictionO[\[Lambda]_,dim_]:=With[{t\[Lambda]=TransposePartition[\[Lambda]]},If[Length[t\[Lambda]]==0,True,If[Length[t\[Lambda]]==1,t\[Lambda][[1]]<=dim,(t\[Lambda][[1]]+t\[Lambda][[2]]<=dim)]]]
SymmetricModuleRestrictionO[\[Mu]_,dim_]:=Length[\[Mu]]<=dim;
RestrictionsO[\[Mu]_,\[Lambda]_,dim_]:=SymmetricModuleRestrictionO[\[Mu],dim]&&BrauerModuleRestrictionO[\[Lambda],dim]
(*** When \[Delta] is an integer N>0 :  we take \[Mu] with at most N boxes in the first raw and \[Lambda] with at most N boxes in the two first raws ***)
BrauerModuleRestrictionSp[\[Lambda]_,dim_]:=If[Length[\[Lambda]]==0,True,\[Lambda][[1]]<=-dim/2];
SymmetricModuleRestrictionSp[\[Mu]_,dim_]:=\[Mu][[1]]<=-dim;
RestrictionsSp[\[Mu]_,\[Lambda]_,dim_]:=SymmetricModuleRestrictionSp[\[Mu],dim]&&BrauerModuleRestrictionSp[\[Lambda],dim]
(*** We will need a function to compute the content of a Young diagram ***)
IntegerPartitionsContent[list_]:=Plus@@Flatten[Map[Range[#]&,list]]-Plus@@(Range[Length[list]]*list);
(*** We need to find all even partition included inside \[Mu] which parametrizes the simple Subscript[S, n]-modules ***)
EvenPartition[ftrace_]:=IntegerPartitions[2*ftrace,ftrace,Table[i,{i,2,2*ftrace,2}]]
MaximalEvenPartitionIn[mu_]:=DeleteCases[Map[2*IntegerPart[#/2]&,mu],0]
EvenPartitionIn[mu_,f_]:=Module[{numax=MaximalEvenPartitionIn[mu]},
Select[EvenPartition[f],IncludedPartitionQ[numax,#]&]
]
EvenPartitionIn[mu_]:=Module[{numax=MaximalEvenPartitionIn[mu],fs},
fs=Range[2,Plus@@numax-2,2];
Append[Flatten[Map[IntegerPartitions[#,{1,Length[numax]},Range[2,numax[[1]],2]]&,fs],1],numax]
]


(* ::Input::Initialization:: *)
(********* Partitions \[Lambda] resulting from inverse rectification of partition \[Nu] in \[Mu] : InverseLittlewoodRichardsonRule[mu,nu] **********)
(*** We obtain the list of pairs of  partitions (\[Mu],\[Lambda]) for a fixed n using "inverse" Littlewood-Richardson rule for the pairs of partitions (\[Mu],\[Nu]) where \[Nu] is an even partition  ***********)
PairsOfPartitions[mu_List,f_]:=Map[{mu,#}&,Flatten[Map[InverseLittlewoodRichardsonRule[mu,#]&,EvenPartitionIn[mu,f]],1]]
PairsOfPartitions[n_Integer,f_]:=Flatten[Map[PairsOfPartitions[#,f]&,Most[IntegerPartitions[n]]],1]
PairsOfPartitions[n_Integer]:=Map[PairsOfPartitions[n,#]&,Range[1,IntegerPart[n/2]]];

(*** Schur-Weyl duality restriction : Maybe need to be change no need for options just do the two cases separatly ****)

PairsOfPartitions[mu_List,f_Integer,dim_Integer,options___?OptionQ]:=Module[{schurweyl=SchurWeylDual/. CheckOptions[options]/. Options[EigenvaluesA],res,n=Plus@@mu},
If[schurweyl===OrthogonalGroup,res=Map[{mu,#}&,Flatten[Map[Select[InverseLittlewoodRichardsonRule[mu,#],BrauerModuleRestrictionO[#,dim]&]&,EvenPartitionIn[mu,f]],1]];
,
If[schurweyl===SymplecticGroup,res=Map[{mu,#}&,Flatten[Map[Select[InverseLittlewoodRichardsonRule[mu,#],BrauerModuleRestrictionSp[#,dim]&]&,EvenPartitionIn[mu,f]],1]],
res=PairsOfPartitions[mu,f]]];
res
]
PairsOfPartitions[n_Integer,f_,dim_,options___?OptionQ]:=Module[{schurweyl=SchurWeylDual/. CheckOptions[options]/. Options[EigenvaluesA],res},
If[schurweyl===OrthogonalGroup,
res=Flatten[Map[PairsOfPartitions[#,f,dim,SchurWeylDual->OrthogonalGroup]&,IntegerPartitions[n,dim]],1],
If[schurweyl===SymplecticGroup,
res=Flatten[Map[PairsOfPartitions[#,f,dim,SchurWeylDual->SymplecticGroup]&,IntegerPartitions[n,n,Range[-dim]]],1],
res=PairsOfPartitions[n,f]]];
res
];

PairsOfPartitionsOrthogonal[n_,dim_]:=Flatten[Map[PairsOfPartitions[n,#,dim,SchurWeylDual->OrthogonalGroup]&,Range[1,IntegerPart[n/2]]],1];
PairsOfPartitionsSymplectic[n_,dim_]:=Flatten[Map[PairsOfPartitions[n,#,dim,SchurWeylDual->SymplecticGroup]&,Range[1,IntegerPart[n/2]]],1];


(* ::Input::Initialization:: *)
(********************************************************************************************************************)
(*** Computing eigenvalues of A on simple Sn module L^(\[Mu]) in the standard module \[CapitalDelta]^(\[Lambda]) of Subscript[B, n](Subscript[\[Delta], b]) where \[Delta] is a parameter ***)
(********************************************************************************************************************)
EigenvaluesA::schurweyl12="The \!\(\*SubscriptBox[\(S\), \(n\)]\)-module  L`1` and/or the \!\(\*SubscriptBox[\(B\), \(n\)]\)-module M`2` does not appear in the tensor space in the context of Schur-Weyl duality for the `3`.";
EigenvaluesA::schurweyl1="The  \!\(\*SubscriptBox[\(B\), \(n\)]\)-module M`1`  does not appear in the tensor space in the context of Schur-Weyl duality for the `2`.";
EigenvaluesA::dimension="The dimension `1` is not compatible with `2`.";

Options[EigenvaluesA]:={SchurWeylDual->None}
EigenvaluesA[mu_List,lambda_List,dim_Symbol|dim_Plus|dim_Times,options:OptionsPattern[]]:=With[{f=(Plus@@mu-Plus@@lambda)/2},
Factor[f(dim-1)+IntegerPartitionsContent[mu]-IntegerPartitionsContent[lambda]]];
EigenvaluesA[mu_List,dim_Symbol|dim_Plus|dim_Times,options:OptionsPattern[]]:=EigenvaluesA[mu,#,dim]&/@Flatten[Map[InverseLittlewoodRichardsonRule[mu,#]&,EvenPartitionIn[mu]],1];
EigenvaluesA[n_,dim_Symbol|dim_Plus|dim_Times,options:OptionsPattern[]]:=EigenvaluesA[#,dim]&/@Most@IntegerPartitions[n];

(********************************************************************************************************************)
(*** Computing eigenvalues of A on simple Sn module L^(\[Mu]) in the standard module \[CapitalDelta]^(\[Lambda]) of Subscript[B, n](Subscript[\[Delta], b]) where \[Delta] is an integer **)
(********************************************************************************************************************)
EigenvaluesA[mu_List,lambda_List,dim_Integer,options:OptionsPattern[]]:=Block[{f=(Plus@@mu-Plus@@lambda)/2,schurweyl},
{schurweyl}=OptionValue[{EigenvaluesA},{options},{SchurWeylDual}];
(**** Error messages ****)
If[schurweyl===OrthogonalGroup,
If[!Positive[dim],Throw@Message[EigenvaluesA::dimension,dim,schurweyl]];
If[!RestrictionsO[mu,lambda,dim],Throw@Message[EigenvaluesA::schurweyl12,mu,lambda,schurweyl]];
];
If[schurweyl===SymplecticGroup,
If[!EvenQ[dim]||Positive[dim],Throw@Message[EigenvaluesA::dimension,dim,schurweyl]];
If[!RestrictionsSp[mu,lambda,dim],Throw@Message[EigenvaluesA::schurweyl12,mu,lambda,schurweyl]];
];
(**** The function ****)
Factor[f(dim-1)+IntegerPartitionsContent[mu]-IntegerPartitionsContent[lambda]]
];

EigenvaluesA[mu_List,dim_Integer,options:OptionsPattern[]]:=Block[{schurweyl,res},
{schurweyl}=OptionValue[{EigenvaluesA},{options},{SchurWeylDual}];
If[schurweyl===OrthogonalGroup,
If[!Positive[dim],Throw@Message[EigenvaluesA::dimension,dim,schurweyl]];
(*If[!SymmetricModuleRestrictionO[mu,dim],Throw@Message[EigenvaluesA::partition1,mu,schurweyl]];*)
res=EigenvaluesA[mu,#,dim,options]&/@Select[Flatten[Map[InverseLittlewoodRichardsonRule[mu,#]&,EvenPartitionIn[mu]],1],BrauerModuleRestrictionO[#,dim]&]
];
If[schurweyl===SymplecticGroup,
If[!EvenQ[dim]||Positive[dim],Throw@Message[EigenvaluesA::dimension,dim,schurweyl]];
If[!SymmetricModuleRestrictionSp[mu,dim],res={},
res=EigenvaluesA[mu,#,dim,options]&/@Select[Flatten[Map[InverseLittlewoodRichardsonRule[mu,#]&,EvenPartitionIn[mu]],1],BrauerModuleRestrictionSp[#,dim]&]];
];
If[schurweyl===None,
res=EigenvaluesA[mu,#,dim,options]&/@Flatten[Map[InverseLittlewoodRichardsonRule[mu,#]&,EvenPartitionIn[mu]],1]
];
res
]

EigenvaluesA[n_,dim_Integer,options:OptionsPattern[]]:=Block[{res,schurweyl},
{schurweyl}=OptionValue[{EigenvaluesA},{options},{SchurWeylDual}];
If[schurweyl===OrthogonalGroup,
If[!Positive[dim],Throw@Message[EigenvaluesA::dimension,dim,schurweyl]];
res=EigenvaluesA[Sequence@@#,dim]&/@PairsOfPartitionsOrthogonal[n,dim]
];
If[schurweyl===SymplecticGroup,
If[!EvenQ[dim]||Positive[dim],Throw@Message[EigenvaluesA::dimension,dim,schurweyl]];
res=EigenvaluesA[Sequence@@#,dim]&/@PairsOfPartitionsSymplectic[n,dim]
];
If[schurweyl===None,
res=EigenvaluesA[Sequence@@#,dim]&/@Flatten[PairsOfPartitions[n],1]
];
res
];
(*************************************************************)
(******************** Default value for dim ******************)
(*************************************************************)
EigenvaluesA[mu_List,lambda_List,options:OptionsPattern[]]:=EigenvaluesA[mu,lambda,BrauerParameter[],options];
EigenvaluesA[mu_List,options:OptionsPattern[]]:=EigenvaluesA[mu,BrauerParameter[],options];
EigenvaluesA[n_,options:OptionsPattern[]]:=EigenvaluesA[n,BrauerParameter[],options];


(******************** Not documented case ******************************************)
EigenvaluesA[n_Integer,lambda_List,dim_Integer,options:OptionsPattern[]]:=Block[{f=(n-Plus@@lambda)/2,res,schurweyl},
{schurweyl}=OptionValue[{EigenvaluesA},{options},{SchurWeylDual}];
If[schurweyl===OrthogonalGroup,
If[!Positive[dim],Throw@Message[EigenvaluesA::dimension,dim,schurweyl]];
If[!BrauerModuleRestrictionO[lambda,dim],Throw@Message[EigenvaluesA::schurweyl1,lambda,schurweyl]];
res=EigenvaluesA[#,lambda,dim,options]&/@Select[IntegerPartitions[n],MemberQ[PairsOfPartitions[n,f],{#,lambda}]&&SymmetricModuleRestrictionO[#,dim]&]
];
If[schurweyl===SymplecticGroup,
If[!EvenQ[dim]||Positive[dim],Throw@Message[EigenvaluesA::dimension,dim,schurweyl]];
If[!BrauerModuleRestrictionSp[lambda,dim],Throw@Message[EigenvaluesA::schurweyl1,lambda,schurweyl]];
res=EigenvaluesA[#,lambda,dim,options]&/@Select[IntegerPartitions[n],MemberQ[PairsOfPartitions[n,f],{#,lambda}]&&SymmetricModuleRestrictionSp[#,dim]&]
];
If[schurweyl===None,
res=EigenvaluesA[#,lambda,dim,options]&/@IntegerPartitions[n]
];
res
]


(* ::Input::Initialization:: *)
(************ New version : we use the quasi-expanded form of the projector see : corrolary 2 in "Traceless projection of tensors
via the Brauer algebra" D.V. Bulakova, Y.O. Goncharov, T. Helpin *****)

TracelessProjector0[n_,dim_Symbol|dim_Plus|dim_Times,options___?OptionQ]:=Block[{partitions=Most@IntegerPartitions[n],eigenvalsPartitions,listfactors,centralYs,rules=ConjugacyClassRelations[AClass[n,1],dim,SymmetricGroup->True]/.HoldForm[ConjugacyClassProduct[{\[Delta]_},a_,b_]]:>Times[a,b]/.Equal->Rule,alltabs=BrauerBracelets[n]},
centralYs=CentralYoungProjector[#]&/@partitions;
eigenvalsPartitions=Map[EigenvaluesA[#,dim]&,partitions];
listfactors=Table[Map[1-(1/#)AClass[n,1]&,eigenvalsPartitions[[i]]],{i,1,PartitionsP[n]-1}];
listfactors[[All,1]]=centralYs[[All]]-1/eigenvalsPartitions[[All,1]]*Map[(Distribute[#])/.rules&,AClass[n,1]*centralYs[[All]]];
Collect[Plus@@Map[Fold[Collect[(Expand[Times[#2,#1]])/.rules,alltabs,Factor]&,#]&,listfactors]+CentralYoungProjector[ConstantArray[1,n]],alltabs,Factor]
]


(* ::Input::Initialization:: *)
TracelessProjectorOrthogonal[n_,dim_]/;GreaterEqual[dim,n]:=Module[{partitions=Most@IntegerPartitions[n],eigenvalsPartitions,listfactors,centralYs,rules=ConjugacyClassRelations[AClass[n,1],dim,SymmetricGroup->True]/.HoldForm[ConjugacyClassProduct[{\[Delta]_},a_,b_]]:>Times[a,b]/.Equal->Rule,alltabs=BrauerBracelets[n],partitionsMissingYoungs},
centralYs=CentralYoungProjector[#]&/@partitions;
eigenvalsPartitions=Map[DeleteCases[DeleteDuplicates[EigenvaluesA[#,dim,SchurWeylDual->OrthogonalGroup]],0]&,partitions];
listfactors=Table[Map[1-(1/#)AClass[n,1]&,eigenvalsPartitions[[i]]],{i,1,Length[partitions]}];
listfactors[[All,1]]=centralYs[[All]]-1/eigenvalsPartitions[[All,1]]*Map[(Distribute[#])/.rules&,AClass[n,1]*centralYs[[All]]];
Collect[Plus@@Map[Fold[Collect[(Expand[Times[#2,#1]])/.rules,alltabs,Factor]&,#]&,listfactors]+CentralYoungProjector[ConstantArray[1,n]],alltabs,Factor]
]
TracelessProjectorOrthogonal[n_,dim_]/;Less[dim,n]:=Module[{partitions,eigenvalsPartitions,listfactors,centralYs,rules,alltabs=BrauerBracelets[n],partitionsMissingYoungs},
partitions=Select[IntegerPartitions[n,dim],BrauerModuleRestrictionO[#,dim]&];
If[partitions==={},Return[0,Module]];
rules=ConjugacyClassRelations[AClass[n,1],dim,SymmetricGroup->True]/.HoldForm[ConjugacyClassProduct[{\[Delta]_},a_,b_]]:>Times[a,b]/.Equal->Rule;
centralYs=CentralYoungProjector[#]&/@partitions;
eigenvalsPartitions=Map[DeleteCases[DeleteDuplicates[EigenvaluesA[#,dim,SchurWeylDual->OrthogonalGroup]],0]&,partitions];
listfactors=Table[Map[1-(1/#)AClass[n,1]&,eigenvalsPartitions[[i]]],{i,1,Length[partitions]}];
listfactors[[All,1]]=centralYs[[All]]-1/eigenvalsPartitions[[All,1]]*Map[(Distribute[#])/.rules&,AClass[n,1]*centralYs[[All]]];
Collect[Plus@@Map[Fold[Collect[(Expand[Times[#2,#1]])/.rules,alltabs,Factor]&,#]&,listfactors],alltabs,Factor]
]
TracelessProjectorSymplectic[n_,dim_]/;LessEqual[dim,-2(n)]:=Module[{partitions=Most@IntegerPartitions[n],eigenvalsPartitions,listfactors,centralYs,rules=ConjugacyClassRelations[AClass[n,1],dim,SymmetricGroup->True]/.HoldForm[ConjugacyClassProduct[{\[Delta]_},a_,b_]]:>Times[a,b]/.Equal->Rule,alltabs=BrauerBracelets[n],partitionsMissingYoungs},
centralYs=CentralYoungProjector[#]&/@partitions;
eigenvalsPartitions=Map[DeleteCases[EigenvaluesA[#,dim,SchurWeylDual->SymplecticGroup],0]&,partitions];
listfactors=Table[Map[1-(1/#)AClass[n,1]&,eigenvalsPartitions[[i]]],{i,1,Length[partitions]}];
listfactors[[All,1]]=centralYs[[All]]-1/eigenvalsPartitions[[All,1]]*Map[(Distribute[#])/.rules&,AClass[n,1]*centralYs[[All]]];
Collect[Plus@@Map[Fold[Collect[(Expand[Times[#2,#1]])/.rules,alltabs,Factor]&,#]&,listfactors]+CentralYoungProjector[ConstantArray[1,n]],alltabs,Factor]
]
TracelessProjectorSymplectic[n_,dim_]/;Greater[dim,-2(n)]:=Module[{partitions,rules,eigenvalsPartitions,listfactors,centralYs,alltabs=BrauerBracelets[n],partitionsMissingYoungs},
partitions=Most@Select[IntegerPartitions[n],BrauerModuleRestrictionSp[#,dim]&];
If[partitions==={},Return[IdClass[n],Module]];
rules=ConjugacyClassRelations[AClass[n,1],dim]/.HoldForm[ConjugacyClassProduct[{\[Delta]_},a_,b_]]:>Times[a,b]/.Equal->Rule;
centralYs=CentralYoungProjector[#]&/@partitions;
eigenvalsPartitions=Map[DeleteCases[EigenvaluesA[#,dim,SchurWeylDual->SymplecticGroup],0]&,partitions];
listfactors=Table[Map[1-(1/#)AClass[n,1]&,eigenvalsPartitions[[i]]],{i,1,Length[partitions]}];
If[listfactors==={{}},listfactors={}];
listfactors[[All,1]]=centralYs[[All]]-1/eigenvalsPartitions[[All,1]]*Map[(Distribute[#])/.rules&,AClass[n,1]*centralYs[[All]]];
Collect[Plus@@Map[Fold[Collect[(Expand[Times[#2,#1]])/.rules,alltabs,Factor]&,#]&,listfactors],alltabs,Factor]
]
TracelessProjectorNone[n_,dim_Integer]:=Block[{rules=ConjugacyClassRelations[AClass[n,1],dim,SymmetricGroup->False]/.HoldForm[ConjugacyClassProduct[{\[Delta]_},a_,b_]]:>Times[a,b]/.Equal->Rule,classhead=AClass[n,1],eigenvals,factors},
eigenvals=DeleteCases[DeleteDuplicates[EigenvaluesA[n,dim,SchurWeylDual->None]],0];
factors=Map[1-(1/#)classhead&,eigenvals];
Fold[Collect[(Times[#2,#1]//Distribute)/.rules,BrauerBracelets[n,SymmetricGroup->False],Factor]&,factors]-1+Bracelets[ConstantArray[{3},n]]
]
TracelessProjector0[n_,dim_Integer,options___?OptionQ]:=With[{schurweyl=SchurWeylDual/.CheckOptions[options]/. Options[TracelessProjector]},
Which[schurweyl===OrthogonalGroup,
If[!Positive[dim],Throw@Message[EigenvaluesA::dimension,dim,schurweyl]];
TracelessProjectorOrthogonal[n,dim],
If[!EvenQ[dim]||Positive[dim],Throw@Message[EigenvaluesA::dimension,dim,schurweyl]];
schurweyl===SymplecticGroup,TracelessProjectorSymplectic[n,dim],
schurweyl===None,TracelessProjectorNone[n,dim]]
]


(* ::Input::Initialization:: *)
SnTracelessProjector0::partition="The partition `1` is not an integer partition of `2`.";


(* ::Input::Initialization:: *)
SnTracelessProjector0[n_,partition_List,dim_,options:OptionsPattern[]]/;(Plus@@partition=!=n):=Throw@Message[SnTracelessProjector0::partition,partition,n]
SnTracelessProjector0[n_,partition_List,dim_Symbol|dim_Plus|dim_Times,options:OptionsPattern[]]/;(Length@partition==n):=Module[{dressed=Dressed/.CheckOptions[options]/. Options[SnTracelessProjector]},
If[dressed===None,Bracelets[ConstantArray[{3},n]],CentralYoungProjector[partition]]]
SnTracelessProjector0[n_,partition_List,dim_Symbol|dim_Plus|dim_Times,options:OptionsPattern[]]/;((Length@partition==1)&&OptionValue[{SnTracelessProjector},{options},{Dressed}]==={None}):=SnTracelessSymProjector[n,dim];

SnTracelessProjector0[n_,partition_List,dim_Symbol|dim_Plus|dim_Times,options:OptionsPattern[]]:=
Module[{dressed=Dressed/.CheckOptions[options]/. Options[SnTracelessProjector],rules,classhead=AClass[n,1],eigenvals=DeleteDuplicates[Flatten[EigenvaluesA[partition,dim]]],factors,brauerBracelets=BrauerBracelets[n,SymmetricGroup->True]},
If[dressed===None,
factors=Map[1-(1/#)classhead&,eigenvals];
If[Length[eigenvals]==1,rules={},
If[Length[eigenvals]==2,rules={AClass[n,1]*AClass[n,1]->ConjugacyClassProduct[{dim},AClass[n,1],AClass[n,1]]},
rules=ConjugacyClassRelations[AClass[n,1],dim,SymmetricGroup->False]/.HoldForm[ConjugacyClassProduct[{\[Delta]_},a_,b_]]:>Times[a,b]/.Equal->Rule
]];
Fold[Collect[(Times[#2,#1]//Distribute)/.rules,brauerBracelets,Factor]&,factors]-1+Bracelets[ConstantArray[{3},n]],
With[{centralyoung=CentralYoungProjector[partition]},
If[Length[eigenvals]==1,rules=ConjugacyClassRelations[AClass[n,1],{0},SymmetricGroup->True]/.HoldForm[ConjugacyClassProduct[{\[Delta]_},a_,b_]]:>Times[a,b]/.Equal->Rule,
rules=ConjugacyClassRelations[AClass[n,1],dim,SymmetricGroup->True]/.HoldForm[ConjugacyClassProduct[{\[Delta]_},a_,b_]]:>Times[a,b]/.Equal->Rule];
factors=Map[1-(1/#)classhead&,eigenvals];
factors[[1]]=centralyoung-1/eigenvals[[1]]*Distribute[AClass[n,1]*centralyoung]/.rules;
Collect[Fold[Collect[Expand[Times[#2,#1]]/.rules,brauerBracelets,Factor]&,factors],brauerBracelets,Factor]
]
]
]
SnTracelessProjector0[n_,partition_List,options___?OptionQ]:=SnTracelessProjector0[n,partition,BrauerParameter[],options]
(********************** Special Case for totally symmetric (resp. antisymmetric for symplectic case) tensors *****************************)
(**** Projector on the space of totally symmetric tensor : Orthogonal group case ****)
SnTracelessSymProjector[n_,dim_]:=Bracelets[ConstantArray[{3},n]]+Sum[(-1)^i*AClass[n,i]*1/Product[(dim+2*(n-j-1)),{j,1,i}],{i,1,IntegerPart[n/2]}];
SnTracelessSymProjector[n_]:=SnTracelessSymProjector[n,BrauerParameter[]]


(* ::Input::Initialization:: *)
SnTracelessProjector0[n_,\[Mu]_List,dim_Integer,options:OptionsPattern[]]:=Module[{classhead=AClass[n,1],schurweyl=SchurWeylDual/.CheckOptions[options]/. Options[SnTracelessProjector],
dressed=Dressed/.CheckOptions[options]/. Options[SnTracelessProjector],brauerBracelets=BrauerBracelets[n,SymmetricGroup->True],rules,eigenvals,factors},
If[schurweyl===OrthogonalGroup,
If[!Positive[dim],Throw@Message[EigenvaluesA::dimension,dim,schurweyl]];
If[!BrauerModuleRestrictionO[\[Mu],dim],Return[0,Module]];
eigenvals=DeleteCases[DeleteDuplicates[Flatten[EigenvaluesA[\[Mu],dim,SchurWeylDual->schurweyl]]],0]
];
If[schurweyl===SymplecticGroup,
If[!EvenQ[dim]||Positive[dim],Throw@Message[EigenvaluesA::dimension,dim,schurweyl]];
If[!BrauerModuleRestrictionSp[\[Mu],dim],Return[0,Module]];
eigenvals=DeleteCases[DeleteDuplicates[Flatten[EigenvaluesA[\[Mu],dim,SchurWeylDual->SymplecticGroup]]],0]
];
If[schurweyl===None,
eigenvals=DeleteCases[DeleteDuplicates[Flatten[EigenvaluesA[\[Mu],dim,SchurWeylDual->None]]],0]
];
If[dressed===None,
If[\[Mu]==={n}&& dim>=n-1,Return[SnTracelessSymProjector[n,dim],Module]];
If[eigenvals=={},Return[Bracelets[ConstantArray[{3},n]],Module]];
rules=ConjugacyClassRelations[AClass[n,1],dim,SymmetricGroup->False]/.HoldForm[ConjugacyClassProduct[{\[Delta]_},a_,b_]]:>Times[a,b]/.Equal->Rule;
factors=Map[1-(1/#)classhead&,eigenvals];
Fold[Collect[(Times[#2,#1]//Distribute)/.rules,brauerBracelets,Factor]&,factors]-1+Bracelets[ConstantArray[{3},n]],
If[dressed===CentralYoungProjector,With[{centralyoung=CentralYoungProjector[\[Mu]]},
If[eigenvals=={},Return[centralyoung,Module]];
rules=ConjugacyClassRelations[AClass[n,1],dim,SymmetricGroup->True]/.HoldForm[ConjugacyClassProduct[{\[Delta]_},a_,b_]]:>Times[a,b]/.Equal->Rule;
factors=Map[1-(1/#)classhead&,eigenvals];
factors[[1]]=centralyoung-1/eigenvals[[1]]*Distribute[AClass[n,1]*centralyoung]/.rules;
Collect[Fold[Collect[Expand[Times[#2,#1]]/.rules,brauerBracelets,Factor]&,factors],brauerBracelets,Factor]
]
]
]
]


(* ::Input::Initialization:: *)
(*********** f-traceless projection on V^(\[TensorProduct]n) **************)
Options[TracelessProjector]:={SchurWeylDual->OrthogonalGroup}
TracelessProjector[n_,{\[Delta]_Symbol|\[Delta]_Integer|\[Delta]_Plus|\[Delta]_Times},options:OptionsPattern[]]:=TracelessProjector0[n,\[Delta],options];
TracelessProjector[n_,options:OptionsPattern[]]:=TracelessProjector[n,{BrauerParameter[]},options];
TracelessProjector[n_,1,{\[Delta]_Symbol|\[Delta]_Integer|\[Delta]_Plus|\[Delta]_Times},options:OptionsPattern[]]:=TracelessProjector[n,{\[Delta]},options]
TracelessProjector[n_,1,options:OptionsPattern[]]:=TracelessProjector[n,options]


(* ::Input::Initialization:: *)
(********** Projection to equivalent simple Brauer modules with f=0 and \[Mu] a partition of n : (1)-traceless subspace **************)
Options[SnTracelessProjector]:={SchurWeylDual->OrthogonalGroup,Dressed->None}
SnTracelessProjector[n_,1,\[Mu]_List,{N_Integer|N_Symbol|N_Plus},options:OptionsPattern[]]:=SnTracelessProjector0[n,\[Mu],N,options];
SnTracelessProjector[n_,1,\[Mu]_List,options:OptionsPattern[]]:=SnTracelessProjector0[n,\[Mu],options];
SnTracelessProjector[n_,\[Mu]_List,{N_Integer|N_Symbol|N_Plus},options:OptionsPattern[]]:=SnTracelessProjector0[n,\[Mu],N,options];
SnTracelessProjector[n_,\[Mu]_List,options:OptionsPattern[]]:=SnTracelessProjector0[n,\[Mu],options];


(* ::Input::Initialization:: *)
ArcMergingFunction0[x1:Bracelets[list_],1]:=With[{symfactor=Count[list,{1,2}]},(1+symfactor)*ToCanonicalBracelets[MergeBracelet[x1,Bracelets[{{1,2}}]]]]
ArcMergingFunction[exp_]:=exp/.x:Bracelets[list_]:>ArcMergingFunction0[x,1]


(* ::Input::Initialization:: *)
MuPartitions[n_,\[Lambda]_]:=Module[{f=(n-Tr[\[Lambda]])/2,\[Nu]s},\[Nu]s=EvenPartition[f];
DeleteDuplicates[Flatten[Map[LittlewoodRichardsonRule[\[Lambda],#]&,\[Nu]s],1]]
]


(* ::Input::Initialization:: *)
(************************************************)
(****************** Initialization **************)
(************************************************)
Options[CentralIdempotent]:={SchurWeylDual->OrthogonalGroup}
CentralIdempotent[2,{},dim_Symbol|dim_Plus|dim_Times,options:OptionsPattern[]]:=1/dim*Bracelets[{{1,2}}]
CentralIdempotent[n_,\[Lambda]_List,dim_Symbol|dim_Plus|dim_Times,options:OptionsPattern[]]/;Length[\[Lambda]]==n:=CentralYoungProjector[\[Lambda]]
CentralIdempotent[n_,\[Lambda]_List,dim_Symbol|dim_Plus|dim_Times,options:OptionsPattern[]]/;Tr[\[Lambda]]==n:=Module[{pairsOfpartition=Select[Flatten[PairsOfPartitions[n],1],#[[1]]===\[Lambda]&],Aclass=AClass[n,1],eigenvalues,factors,ruleAclass=ConjugacyClassRelations[AClass[n,1],dim,SymmetricGroup->True]/.HoldForm[ConjugacyClassProduct[{\[Delta]_},a_,b_]]:>Times[a,b]/.Equal->Rule},
(*Print[ruleAclass];*)
eigenvalues=(EigenvaluesA[Sequence@@#,dim]&/@pairsOfpartition);
factors=Join[Map[1-Aclass/(#)&,Most[eigenvalues]],{CentralYoungProjector[\[Lambda]]-Collect[1/Last[eigenvalues]Distribute[Times[Aclass,CentralYoungProjector[\[Lambda]]]]/.ruleAclass,{_Bracelets},Factor]}];
Collect[Fold[Collect[(Expand[Times[#2,#1]])/.ruleAclass,{_Bracelets},Factor[#]&]&,Reverse@factors],{_Bracelets},Factor]
]


(* ::Input::Initialization:: *)
CentralIdempotentBranching[n_,{\[Mu]_List,\[Lambda]_List},dim_Symbol|dim_Plus|dim_Times,previousCentralIdempotent_,ruleProductAClass_,options:OptionsPattern[]]:=Module[{\[Rho]s=MuPartitions[n,\[Lambda]],evA=EigenvaluesA[\[Mu],\[Lambda],dim],\[Rho]sNew,factors,f=(n-Tr[\[Lambda]])/2,AtimespreviousCentralIdempotent,Aclass=AClass[n,1]},
(*Print[\[Rho]s];*)
\[Rho]sNew=Select[\[Rho]s,EigenvaluesA[#,\[Lambda],dim]=!=evA&];
\[Rho]sNew=DeleteDuplicates[\[Rho]sNew,EigenvaluesA[#1,\[Lambda],dim]==EigenvaluesA[#2,\[Lambda],dim]&];
(*If[n==9||n==10||n==11||n==12,Print["rho 2: ",\[Rho]sNew]];*)
(*Print[evA];*)
If[\[Rho]sNew==={},
Return[previousCentralIdempotent/evA,Module]];
(********* An * previousCentralIdempotent *******)
AtimespreviousCentralIdempotent=Collect[Expand[Times[Aclass,previousCentralIdempotent]]/.ruleProductAClass,{_Bracelets},Factor];
If[Length[\[Rho]sNew]===1,
Return[Collect[(EigenvaluesA[\[Rho]sNew[[1]],\[Lambda],dim]*previousCentralIdempotent-AtimespreviousCentralIdempotent)/(evA*(EigenvaluesA[\[Rho]sNew[[1]],\[Lambda],dim]-evA)),{_Bracelets},Factor],Module];
];
factors=Join[{Collect[(EigenvaluesA[\[Rho]sNew[[1]],\[Lambda],dim]previousCentralIdempotent-AtimespreviousCentralIdempotent)/(evA*(EigenvaluesA[\[Rho]sNew[[1]],\[Lambda],dim]-evA)),{_Bracelets},Factor]},Map[(EigenvaluesA[#,\[Lambda],dim]-Aclass)/(EigenvaluesA[#,\[Lambda],dim]-evA)&,Rest[\[Rho]sNew]]];
(*Print[factors];*)
Return[Collect[(Fold[Collect[(Expand[Times[#2,#1]])/.ruleProductAClass,{_Bracelets},Factor]&,factors]),{_Bracelets},Factor],Module];
]


(* ::Input::Initialization:: *)
CentralIdempotent[n_,\[Lambda]_List,dim_Symbol|dim_Plus|dim_Times,options:OptionsPattern[]]:=Module[{\[Mu]s=MuPartitions[n,\[Lambda]],previousCentralIdempotent=ArcMergingFunction[CentralIdempotent[n-2,\[Lambda],dim]],ruleProductAClass=ConjugacyClassRelations[AClass[n,1],{(n-Tr[\[Lambda]])/2,IntegerPart[n/2]},dim]/.HoldForm[ConjugacyClassProduct[{\[Delta]_},a_,b_]]:>Times[a,b]/.Equal->Rule,\[Mu]sNew},
\[Mu]sNew=DeleteDuplicates[\[Mu]s,EigenvaluesA[#1,\[Lambda],dim]==EigenvaluesA[#2,\[Lambda],dim]&];
Collect[Plus@@Map[CentralIdempotentBranching[n,{#,\[Lambda]},dim,previousCentralIdempotent,ruleProductAClass,options]&,\[Mu]sNew],{_Bracelets},Factor]
]
CentralIdempotent[n_,\[Lambda]_List,options:OptionsPattern[]]:=CentralIdempotent[n,\[Lambda],BrauerParameter[],options];
(************ f in the input *************)
CentralIdempotent[n_,f_Integer,\[Lambda]_List,dim_Symbol|dim_Plus|dim_Times,options:OptionsPattern[]]/;f==(n-Plus@@\[Lambda])/2:=CentralIdempotent[n,\[Lambda],dim,options];
CentralIdempotent::f="The parameter f=`1` is not compatible with the partition `2`.";
CentralIdempotent[n_,f_Integer,\[Lambda]_List,dim_Symbol|dim_Plus|dim_Times,options:OptionsPattern[]]/;f!=(n-Plus@@\[Lambda])/2:=Throw@Message[CentralIdempotent::f,f,\[Lambda]];
CentralIdempotent[n_,f_Integer,\[Lambda]_List,options:OptionsPattern[]]:=CentralIdempotent[n,f,\[Lambda],BrauerParameter[],options];
(************ (f+1)-traceless idempotents *************)
CentralIdempotent[n_,f_Integer,dim_Symbol|dim_Plus|dim_Times,options:OptionsPattern[]]:=With[{list\[Lambda]=IntegerPartitions[n-2f]},
Collect[Sum[CentralIdempotent[n,list\[Lambda][[i]],dim,options],{i,1,Length[list\[Lambda]]}],{_Bracelets},Factor]];
CentralIdempotent[n_,f_Integer,options:OptionsPattern[]]:=CentralIdempotent[n,f,BrauerParameter[],options];


(* ::Input::Initialization:: *)
(********** Private function **********)
CentralIdempotentInduction[n_,\[Lambda]_List,dim_Symbol|dim_Plus|dim_Times,previousCentralIdempotent_,options:OptionsPattern[]]:=Module[{\[Mu]s=MuPartitions[n,\[Lambda]],ArcMergedpreviousCentralIdempotent=ArcMergingFunction[previousCentralIdempotent],ruleProductAClass=ConjugacyClassRelations[AClass[n,1],{(n-Tr[\[Lambda]])/2,IntegerPart[n/2]},dim]/.HoldForm[ConjugacyClassProduct[{\[Delta]_},a_,b_]]:>Times[a,b]/.Equal->Rule,\[Mu]sNew},
\[Mu]sNew=DeleteDuplicates[\[Mu]s,EigenvaluesA[#1,\[Lambda],dim]==EigenvaluesA[#2,\[Lambda],dim]&];
Collect[Plus@@Map[CentralIdempotentBranching[n,{#,\[Lambda]},dim,ArcMergedpreviousCentralIdempotent,ruleProductAClass,options]&,\[Mu]sNew],{_Bracelets},Factor]
]
CentralIdempotentInduction[n_,\[Lambda]_List,previousCentralIdempotent_,options:OptionsPattern[]]:=CentralIdempotentInduction[n,\[Lambda],BrauerParameter[],previousCentralIdempotent,options]


(* ::Input::Initialization:: *)
MuPartitions[n_,\[Lambda]_,dim_Integer]:=Module[{f=(n-Tr[\[Lambda]])/2,\[Nu]s,\[Mu]s0},\[Nu]s=EvenPartition[f];
\[Mu]s0=DeleteDuplicates[Flatten[Map[LittlewoodRichardsonRule[\[Lambda],#]&,\[Nu]s],1]];
Select[Select[\[Mu]s0,EigenvaluesA[#,\[Lambda],dim]>0&],TransposePartition[#][[1]]<=dim&]
]


(* ::Input::Initialization:: *)
(************************************************)
(****************** Initialization **************)
(************************************************)
CentralIdempotent[2,{},dim_Integer,options:OptionsPattern[]]:=1/dim*Bracelets[{{1,2}}]
CentralIdempotent[n_,\[Lambda]_,dim_Integer,options:OptionsPattern[]]/;Tr[\[Lambda]]==n:=Module[{eigenvalues,ruleidclass,factors,schurweyl=SchurWeylDual/.CheckOptions[options]/. Options[CentralIdempotent]},
If[schurweyl===OrthogonalGroup,
If[!BrauerModuleRestrictionO[\[Lambda],dim],Return[0,Module]]];
If[Length[\[Lambda]]==n,Return[CentralYoungProjector[\[Lambda]],Module]];
With[{pairsOfpartition=Select[Flatten[PairsOfPartitions[n],1],#[[1]]===\[Lambda]&],ruleAclass=ConjugacyClassRelations[AClass[n,1],dim,SymmetricGroup->True]/.HoldForm[ConjugacyClassProduct[{\[Delta]_},a_,b_]]:>Times[a,b]/.Equal->Rule,idclass=IdClass[n],Aclass=AClass[n,1]},
(*Print[ruleAclass];*)
If[schurweyl===OrthogonalGroup,
eigenvalues=DeleteCases[EigenvaluesA[Sequence@@#,dim]&/@pairsOfpartition,a_?(#<=0&)],
eigenvalues=DeleteCases[EigenvaluesA[Sequence@@#,dim]&/@pairsOfpartition,0]
];
If[eigenvalues==={},Return[CentralYoungProjector[\[Lambda]],Module]];
factors=Join[Map[1-Aclass/(#)&,Most[eigenvalues]],{CentralYoungProjector[\[Lambda]]-Collect[1/Last[eigenvalues]Distribute[Times[Aclass,CentralYoungProjector[\[Lambda]]]]/.ruleAclass,{_Bracelets},Factor]}];
Collect[Fold[Collect[(Distribute[Times[#2,#1]])/.ruleAclass,{_Bracelets},Factor[#]&]&,Reverse@factors],{_Bracelets},Factor]
]
]


(* ::Input::Initialization:: *)
(********** Not used in the algorithm ***********)
CentralIdempotentBranching[n_,{\[Mu]_List,\[Lambda]_List},dim_Integer,options:OptionsPattern[]]:=If[!MemberQ[BranchingRule[\[Mu],GeneralLinearGroup,OrthogonalGroup],\[Lambda]],0,Module[{\[Rho]s=MuPartitions[n,\[Lambda],dim],ruleProductAClass=ConjugacyClassRelations[AClass[n,1],dim,SymmetricGroup->False]/.HoldForm[ConjugacyClassProduct[{\[Delta]_},a_,b_]]:>Times[a,b]/.Equal->Rule,evA=EigenvaluesA[\[Mu],\[Lambda],dim],\[Rho]sNew,factors,f=(n-Tr[\[Lambda]])/2,previousCentralIdempotent,AtimespreviousCentralIdempotent,Aclass=AClass[n,1]},
(*Print[\[Rho]s];*)
\[Rho]sNew=Select[\[Rho]s,EigenvaluesA[#,\[Lambda],dim]=!=evA&];
(*Print[\[Rho]sNew];*)
(*Print[evA];*)
(************* Central idempotent n-2 ****************)
previousCentralIdempotent=ArcMergingFunction[CentralIdempotent[n-2,f-1,\[Lambda],dim]];
If[\[Rho]sNew==={},
Return[previousCentralIdempotent/evA,Module]];
AtimespreviousCentralIdempotent=Collect[Expand[Times[Aclass,previousCentralIdempotent]]/.ruleProductAClass,{_Bracelets},Factor];
(************* Formula ****************************)
If[Length[\[Rho]sNew]===1,
Return[Collect[(EigenvaluesA[\[Rho]sNew[[1]],\[Lambda],dim]previousCentralIdempotent-AtimespreviousCentralIdempotent)/(evA*(EigenvaluesA[\[Rho]sNew[[1]],\[Lambda],dim]-evA)),{_Bracelets},Factor],Module];
];
factors=Join[{Collect[(EigenvaluesA[\[Rho]sNew[[1]],\[Lambda],dim]previousCentralIdempotent-AtimespreviousCentralIdempotent)/(evA*(EigenvaluesA[\[Rho]sNew[[1]],\[Lambda],dim]-evA)),{_Bracelets},Factor]},Map[(EigenvaluesA[#,\[Lambda],dim]-Aclass)/(EigenvaluesA[#,\[Lambda],dim]-evA)&,Rest[\[Rho]sNew]]];
(*Print[factors];*)
Return[Collect[(Fold[Collect[(Expand[Times[#2,#1]])/.ruleProductAClass,{_Bracelets},Factor]&,factors]),{_Bracelets},Factor],Module];
]
]
(********** Used in the algorithm ***********)
CentralIdempotentBranching[n_,{\[Mu]_List,\[Lambda]_List},dim_Integer,previousCentralIdempotent_,ruleProductAClass_,options:OptionsPattern[]]:=Module[{\[Rho]s=MuPartitions[n,\[Lambda],dim],evA=EigenvaluesA[\[Mu],\[Lambda],dim],\[Rho]sNew,factors,f=(n-Tr[\[Lambda]])/2,AtimespreviousCentralIdempotent,Aclass=AClass[n,1]},
(*Print[\[Rho]s];*)
\[Rho]sNew=Select[\[Rho]s,EigenvaluesA[#,\[Lambda],dim]=!=evA&];
\[Rho]sNew=DeleteDuplicates[\[Rho]sNew,EigenvaluesA[#1,\[Lambda],dim]==EigenvaluesA[#2,\[Lambda],dim]&];
(*If[n==9,Print[\[Rho]sNew]];*)
(*Print[n,":",\[Rho]sNew];
Print[n,":",evA];*)
If[\[Rho]sNew==={},
Return[previousCentralIdempotent/evA,Module]];
(********* An * previousCentralIdempotent *******)
AtimespreviousCentralIdempotent=Collect[Expand[Times[Aclass,previousCentralIdempotent]]/.ruleProductAClass,{_Bracelets},Factor];
If[Length[\[Rho]sNew]===1,
Return[Collect[(EigenvaluesA[\[Rho]sNew[[1]],\[Lambda],dim]*previousCentralIdempotent-AtimespreviousCentralIdempotent)/(evA*(EigenvaluesA[\[Rho]sNew[[1]],\[Lambda],dim]-evA)),{_Bracelets},Factor],Module];
];
factors=Join[{Collect[(EigenvaluesA[\[Rho]sNew[[1]],\[Lambda],dim]previousCentralIdempotent-AtimespreviousCentralIdempotent)/(evA*(EigenvaluesA[\[Rho]sNew[[1]],\[Lambda],dim]-evA)),{_Bracelets},Factor]},Map[(EigenvaluesA[#,\[Lambda],dim]-Aclass)/(EigenvaluesA[#,\[Lambda],dim]-evA)&,Rest[\[Rho]sNew]]];
(*Print[factors];*)
Return[Collect[(Fold[Collect[(Expand[Times[#2,#1]])/.ruleProductAClass,{_Bracelets},Factor]&,factors]),{_Bracelets},Factor],Module];
]


(* ::Input::Initialization:: *)
CentralIdempotent[n_,\[Lambda]_List,dim_Integer,options:OptionsPattern[]]:=Module[{\[Mu]s=MuPartitions[n,\[Lambda],dim],previousCentralIdempotent,ruleProductAClass,\[Mu]sNew,schurweyl=SchurWeylDual/.CheckOptions[options]/. Options[CentralIdempotent]},
If[schurweyl===OrthogonalGroup,
If[!BrauerModuleRestrictionO[\[Lambda],dim],Return[0,Module]];
ruleProductAClass=ConjugacyClassRelations[AClass[n,1],{(n-Tr[\[Lambda]])/2,IntegerPart[n/2]},dim]/.HoldForm[ConjugacyClassProduct[{\[Delta]_},a_,b_]]:>Times[a,b]/.Equal->Rule;
previousCentralIdempotent=ArcMergingFunction[CentralIdempotent[n-2,\[Lambda],dim]];
\[Mu]s=MuPartitions[n,\[Lambda],dim];
\[Mu]sNew=DeleteDuplicates[\[Mu]s,EigenvaluesA[#1,\[Lambda],dim]==EigenvaluesA[#2,\[Lambda],dim]&];
Collect[Plus@@Map[CentralIdempotentBranching[n,{#,\[Lambda]},dim,previousCentralIdempotent,ruleProductAClass,options]&,\[Mu]sNew],{_Bracelets},Factor]
]
]
(************ f in the input *************)
CentralIdempotent[n_,f_Integer,\[Lambda]_List,dim_Integer,options:OptionsPattern[]]/;f==(n-Plus@@\[Lambda])/2:=CentralIdempotent[n,\[Lambda],dim,options];
CentralIdempotent::f="The parameter f=`1` is not compatible with the partition `2`.";
CentralIdempotent[n_,f_Integer,\[Lambda]_List,dim_Symbol|dim_Plus|dim_Times,options:OptionsPattern[]]/;f!=(n-Plus@@\[Lambda])/2:=Throw@Message[CentralIdempotent::f,f,\[Lambda]];
(************ (f+1)-traceless idempotents *************)
CentralIdempotent[n_,f_Integer,dim_Integer,options:OptionsPattern[]]:=With[{list\[Lambda]=IntegerPartitions[n-2f]},
Collect[Sum[CentralIdempotent[n,list\[Lambda][[i]],dim,options],{i,1,Length[list\[Lambda]]}],{_Bracelets},Factor]];


(* ::Input::Initialization:: *)
(********** Private function **********)
CentralIdempotentInduction[n_,\[Lambda]_List,dim_Integer,previousCentralIdempotent_,options:OptionsPattern[]]:=Module[{\[Mu]s=MuPartitions[n,\[Lambda],dim],ArcMergedpreviousCentralIdempotent=ArcMergingFunction[previousCentralIdempotent],ruleProductAClass,\[Mu]sNew,schurweyl=SchurWeylDual/.CheckOptions[options]/. Options[CentralIdempotent]},
If[schurweyl===OrthogonalGroup,
If[!BrauerModuleRestrictionO[\[Lambda],dim],Return[0,Module]];
ruleProductAClass=ConjugacyClassRelations[AClass[n,1],{(n-Tr[\[Lambda]])/2,IntegerPart[n/2]},dim]/.HoldForm[ConjugacyClassProduct[{\[Delta]_},a_,b_]]:>Times[a,b]/.Equal->Rule;
\[Mu]s=MuPartitions[n,\[Lambda],dim];
\[Mu]sNew=DeleteDuplicates[\[Mu]s,EigenvaluesA[#1,\[Lambda],dim]==EigenvaluesA[#2,\[Lambda],dim]&];
Collect[Plus@@Map[CentralIdempotentBranching[n,{#,\[Lambda]},dim,ArcMergedpreviousCentralIdempotent,ruleProductAClass,options]&,\[Mu]sNew],{_Bracelets},Factor]
]
]


(* ::Input::Initialization:: *)
(*********** f-traceless projection on V^(\[TensorProduct]n) **************)
TracelessProjector[n_,f_Integer,options:OptionsPattern[]]/;f>1:=CentralIdempotent[n,f-1]
TracelessProjector[n_,f_Integer,{dim_Symbol|dim_Integer|dim_Plus},options:OptionsPattern[]]/;f>1:=CentralIdempotent[n,f-1]/.BrauerParameter[]->dim


(* ::Input::Initialization:: *)
(*********** f-trace projection on V^(\[TensorProduct]n) **************)
Options[TraceProjector]:={SchurWeylDual->OrthogonalGroup}
TraceProjector[n_,options:OptionsPattern[]]:=CentralIdempotent[n,IntegerPart[n/2]];
TraceProjector[n_,{N_Integer|N_Symbol|N_Plus|N_Times},options:OptionsPattern[]]:=CentralIdempotent[n,IntegerPart[n/2]]/.BrauerParameter[]->N;


(* ::Input::Initialization:: *)
CanonicalPrimitiveIdempotent::Brauer="There number of partition in `1` is not equal to `2`.";
CanonicalPrimitiveIdempotent[n_,path_List,rest___]/;Length[path]!=n:=Throw[Message[CanonicalPrimitiveIdempotent::Brauer,path,n]]
CanonicalPrimitiveIdempotent[n_,path_List,dim_Symbol|dim_Times|dim_Plus]/;DimOfIrrepBn[n,Last[path]]==1:=Collect[PermToBrauer[ConjugacyClassSum[CentralIdempotent[n,Last[path],dim]],n],{_BrauerList},Factor];
CanonicalPrimitiveIdempotent[n_,path_List,dim_Symbol|dim_Times|dim_Plus]:=CanonicalPrimitiveIdempotent[n,path,dim]=Collect[BrauerProduct[{dim},MergeBrauer[CanonicalPrimitiveIdempotent[n-1,Most[path],dim],IdentityBrauer[1]],ConjugacyClassSum[CentralIdempotent[n,Last[path],dim]]],{_BrauerList},Factor];
CanonicalPrimitiveIdempotent[n_,path_List]:=CanonicalPrimitiveIdempotent[n,path,BrauerParameter[]]


(* ::Input::Initialization:: *)
CanonicalPrimitiveIdempotent[n_,path_List,rest___]/;Length[path]!=n:=Throw[Message[CanonicalPrimitiveIdempotent::Brauer,path,n]]
CanonicalPrimitiveIdempotent[n_,path_List,dim_Integer]/;!AllTrue[Map[BrauerModuleRestrictionO[#,dim]&,path],#&]:=0;
CanonicalPrimitiveIdempotent[n_,path_List,dim_Integer]/;DimOfIrrepBn[n,Last[path]]==1:=Collect[PermToBrauer[ConjugacyClassSum[CentralIdempotent[n,Last[path],dim]],n],{_BrauerList},Factor];
CanonicalPrimitiveIdempotent[n_,path_List,dim_Integer]:=CanonicalPrimitiveIdempotent[n,path,dim]=Collect[BrauerProduct[{dim},MergeBrauer[CanonicalPrimitiveIdempotent[n-1,Most[path],dim],IdentityBrauer[1]],ConjugacyClassSum[CentralIdempotent[n,Last[path],dim]]],{_BrauerList},Factor];


(* ::Input::Initialization:: *)
SplittingIdempotent::arcs="There cannot be `1` arcs in Brauer on `2` vertices.";


(* ::Input::Initialization:: *)
(********* This rule is used for maximal trace projector when we use Weingarten calculus *******)
rulePtoNS[btab_Bracelets]:=btab/.{3}->{1,2}/. 3->Sequence@@{1,2}


(* ::Input::Initialization:: *)
(************ Two version for the splitting idempotent : the first one use the formula of the article, the second inverse the matrix : for the splitting indempotent of the first exact sequence 0->J(1)->Subscript[B, n](Subscript[\[Delta], b])->Subscript[B, n](Subscript[\[Delta], b])/J(1) (traceless projector) **********)


SplittingIdempotent1[n_,f_,\[Delta]_Symbol|\[Delta]_Integer|\[Delta]_Plus]:=Module[{Aclass=AClass[n,f],tabs=BrauerBracelets[n,f,IntegerPart[n/2]],relations,eigenvalues,factors,rules,weinO,tabseven,tabsasso},
If[f>IntegerPart[n/2],Throw@Message[SplittingIdempotent::arcs,f,n]];
(******** If number of arc if maximal we use Weingarten calculus to compute the splitting idempotent *****)
If[f==IntegerPart[n/2],
If[EvenQ[n],
	weinO=WeingartenO[#,\[Delta]]&/@tabs;
	Return[Bracelets[ConstantArray[{3},n]]-Plus@@Thread[Times[weinO,tabs]],Module],
	tabseven=Flatten@BrauerBracelets[n+1,f+1];
	tabsasso=#->rulePtoNS[#]&/@tabs;
	weinO=#->WeingartenO[#,\[Delta]]&/@tabseven;
	Return[Bracelets[ConstantArray[{3},n]]-Plus@@(\[Delta]*#[[2]]*#[[1]]&/@(tabsasso/.weinO)),Module]]
];
(******** We use the factorized formula for the splitting idempotent presented in the article *****)
relations=ConjugacyClassRelations[Aclass,{f,IntegerPart[n/2]},\[Delta],FactorSpace->False];
eigenvalues=DeleteDuplicates[Eigenvalues[ExtractStructureConstantIdeal[relations]]];
factors=Map[1-(1/#)Aclass&,eigenvalues];
rules=relations/.NonCommutativeMultiply->Times/.Equal->Rule;
Fold[Collect[(Distribute[Times[#2,#1]])/.rules,tabs,Factor[Simplify[#]]&]&,factors]-1+Bracelets[ConstantArray[{3},n]]
];
SplittingIdempotent1[n_,f_]:=SplittingIdempotent1[n,f,BrauerParameter[]];
(***** old algorithm need inversion of a matrix except for maximal arc -> Weingarten calculus : *********)
(***** The splitting idempotents can be obtained more efficiently via the CentralIdempotent algortihm which uses only class Subscript[A, 1] : To do  *********)
SplittingIdempotent[n_,f_,\[Delta]_Symbol|\[Delta]_Integer|\[Delta]_Plus|\[Delta]_Times]:=Module[{Aclass=AClass[n,f],tabs=Flatten@BrauerBracelets[n,f,IntegerPart[n/2]],weinO,tabseven,tabsasso},
If[f>IntegerPart[n/2],Throw@Message[SplittingIdempotent::arcs,f,n]];
(******** If number of arc if maximal we use Weingarten calculus to compute the splitting idempotent *****)
If[f==IntegerPart[n/2],
If[EvenQ[n],
	weinO=WeingartenO[#,\[Delta]]&/@tabs;
	Return[Bracelets[ConstantArray[{3},n]]-Plus@@Thread[Times[weinO,tabs]],Module],
	tabseven=Flatten@BrauerBracelets[n+1,f+1];
	tabsasso=#->rulePtoNS[#]&/@tabs;
	weinO=#->WeingartenO[#,\[Delta]]&/@tabseven;
	Return[Bracelets[ConstantArray[{3},n]]-Plus@@(\[Delta]*#[[2]]*#[[1]]&/@(tabsasso/.weinO)),Module]]
];
(******** We use inversion of the matrix of structure constant : this is actually faster *****)
-1*(tabs . (Factor[Inverse[Transpose[StructureConstant[Aclass,\[Delta],FactorSpace->False,IdealSpace->True]]]][[1]]))+IdClass[n]
];
SplittingIdempotent[n_,f_]:=SplittingIdempotent[n,f,BrauerParameter[]];
(*TracelessProjector0 is the new function to compute the 1-traceless projector. It is much more efficient than the previous SplittingIdempotent function for f=1.*)
SplittingIdempotent[n_,1]:=TracelessProjector0[n,BrauerParameter[]];
SplittingIdempotent[n_,1,dim_]:=TracelessProjector0[n,dim];


(* ::Input::Initialization:: *)
RuleBinaryCycleType={{1,a___,2,b___}:>Join[ConstantArray[0,Length[List[a]]+1],ConstantArray[1,Length[List[b]]+1]]}
ToBinaryCycleTypeList[btablist_List?(SymGroupQ[#]===False&)]:=Flatten[Split[btablist,#2!=1&]/.RuleBinaryCycleType]
ToBinaryCycleTypeList[btablist_?(Equal@@#&)]:=ConstantArray[0,Length[btablist]];
ToBinaryCycleType[btab_Bracelets]:=Map[RotateLeft[ToBinaryCycleTypeList[#],1]&,Sequence@@btab];
PreCycleType[btab_]:=Map[ReverseSort[{Count[#,0],Count[#,1]}]&,ToBinaryCycleType[btab]]
CycleType[btab_Bracelets]:=ReverseSort[Map[#[[1]]-#[[2]]&,PreCycleType[btab]]]


(* ::Input::Initialization:: *)
CycleType[cycle_System`Cycles,n_]:=With[{ct0=Length/@cycle[[1]]},ReverseSort[PadRight[ct0,n-Plus@@ct0+Length[ct0],1]]];
CycleType[perm_?PermutationListQ]:=CycleType[PermutationCycles[perm],Length[perm]];
CycleType[blist_?SymmetricGroupQ]:=CycleType[BrauerToPerm[blist],Length@@blist];


(* ::Input::Initialization:: *)
CycleType[blist_BrauerList]:=CycleType[ToBracelets[blist]];


(* ::Input::Initialization:: *)
(*Function from\cite{collins06integration}*)
WeingartenU[permutationType_,\[Delta]_Symbol|\[Delta]_Integer]:=
Block[{func,n},func=(CharacterSymmetricGroup[#])^2 CharacterSymmetricGroup[#,permutationType]/DimOfIrrepGL[#,\[Delta]]&;
n=Total[permutationType];
Factor[1/(n!)^2 Fold[#1+func[#2]&,0,IntegerPartitions[n]]]
];
WeingartenU[permutationType_]:=WeingartenU[permutationType,BrauerParameter[]];


(* ::Input::Initialization:: *)
PermutationEmbedding[BrauerList[list_],n_]:=PermutationCycles[Flatten[list/.DownInteger[i_]:>i+n]];
PermutationEmbedding[x:BrauerList[list_]]:=PermutationEmbedding[x,Length[list]]


(* ::Input::Initialization:: *)
InputWeingardenToPerm[blist1_,blist2_]:=PermutationProduct[InversePermutation[PermutationEmbedding[blist1]],PermutationEmbedding[blist1]]


(* ::Input::Initialization:: *)
HyperOctahedralQ[perm_System`Cycles,n_]:=SameQ[PermutationProduct[Cycles[Partition[Range[n],{2}]],perm],PermutationProduct[perm,Cycles[Partition[Range[n],{2}]]]]
HyperOctahedralQ[perm_?PermutationListQ]:=HyperOctahedralQ[PermutationCycles[perm],Length[perm]]


(* ::Input::Initialization:: *)
HyperOctahedralGenerators[n_]:=Block[{pairpart=Partition[Range[2n],{2}],paircycles},
paircycles=Thread[List[{1,2},#]]&/@Drop[pairpart,1];
System`Cycles/@Join[Map[{#}&,pairpart],paircycles]
]


(* ::Input::Initialization:: *)
HyperOctahedralGroup[n_]:=PermutationGroup[HyperOctahedralGenerators[n]]


(* ::Input::Initialization:: *)
GammaList[d_]:=Block[{n=Length@@d,list1,list2},
list1=Partition[Range[n],{2}];
list2=Partition[(#[[2]]&/@(Sequence@@d))-n,{2}];
{list1,list2}
]


(* ::Input::Initialization:: *)
gatherpairs[list_]:=FixedPoint[Function[l,Catenate/@Gather[l,ContainsAny[Flatten[#],Flatten[#2]]&]],list]
GammaList[perm_System`Cycles,n_]:=GammaList[PermToBrauer[perm,n]];
GammaListToPartition[gammalist_List]:=ReverseSort[(Length/@gatherpairs[gammalist])/4];
CosetType[blist_?SymmetricGroupQ]:=GammaListToPartition[Flatten[GammaList[blist],1]];
CosetType[perm_System`Cycles,n_]:=GammaListToPartition[Flatten[GammaList[perm,n],1]];
CosetType[blist1_BrauerList,blist2_BrauerList]:=GammaListToPartition[Flatten[GammaList[InputWeingardenToPerm[blist1,blist2]],1]];


(* ::Input::Initialization:: *)
ZonalSpherical[partition_,cycle_System`Cycles,n_]:=Module[{prodperms,partitions},
prodperms=PermutationProduct[cycle,#]&/@(GroupElements@HyperOctahedralGroup[n]);
partitions=CycleType[#,2*n]&/@prodperms;
1/((2n)!!)*(Total@(CharacterSymmetricGroup[2*partition,#]&/@partitions))
];


(* ::Input::Initialization:: *)
ZonalSpherical[partition_,blist1_,blist2_]:=ZonalSpherical[partition,PermutationProduct[InversePermutation[PermutationEmbedding[blist1]],PermutationEmbedding[blist2]],Length@@blist1];


(* ::Input::Initialization:: *)
ZonalPolynomialId[partition_,\[Delta]_Integer|\[Delta]_Symbol]:=Module[{row=Length[partition],i=0,prod=1,j=0},
While[i<row,i++;
While[j<partition[[i]],j++;
prod=prod*(\[Delta]+2j-i-1)
];j=0];
prod
]
ZonalPolynomialId[partition_]:=ZonalPolynomialId[partition,BrauerParameter[]];


(* ::Input::Initialization:: *)
WeingartenO[blist1_BrauerList,blist2_BrauerList,\[Delta]_Integer|\[Delta]_Symbol]:=With[{n=(Length@@blist1)},
1/((2n-1)!!)*Plus@@Map[CharacterSymmetricGroup[2*#]*ZonalSpherical[#,blist1,blist2]/ZonalPolynomialId[#,\[Delta]]&,IntegerPartitions[n]]//Factor
]
WeingartenO[blist1_BrauerList,blist2_BrauerList]:=WeingartenO[blist1,blist2,BrauerParameter[]]


(* ::Input::Initialization:: *)
BraceletsToInputWeingarten[x:Bracelets[list_]]:=
BrauerList/@Partition[UpInteger@@ToRepresentativeDiagram[x],Length[Flatten[list]]/2]


(* ::Input::Initialization:: *)
WeingartenO[btab_Bracelets,\[Delta]_Integer|\[Delta]_Symbol]:=WeingartenO[Sequence@@BraceletsToInputWeingarten[btab],\[Delta]];
WeingartenO[btab_Bracelets]:=WeingartenO[btab,BrauerParameter[]];


(* ::Input::Initialization:: *)
End[];
Protect@@Names["BrauerAlgebra`*"]
Unprotect["SemiNormalYoungUnit","CanonicalPrimitiveIdempotent"]
EndPackage[];
